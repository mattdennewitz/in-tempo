---
phase: 02-ensemble-ai
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/audio/types.ts
  - src/score/ensemble.ts
  - src/score/ensemble.test.ts
autonomous: true

must_haves:
  truths:
    - "Ensemble of N agents can be created with distinct personalities"
    - "Each agent makes weighted decisions (advance/repeat/dropout) at pattern boundaries"
    - "Band enforcement prevents any performer from being more than 3 patterns ahead of the lowest active performer"
    - "Dropout/rejoin creates natural breathing -- agents go silent then return"
    - "Unison seeking causes agents to cluster on the same pattern periodically"
    - "Endgame logic causes staggered dropouts when performers reach pattern 53"
    - "All agents evaluate against the same immutable snapshot per tick (no order-of-evaluation bugs)"
  artifacts:
    - path: "src/score/ensemble.ts"
      provides: "Ensemble coordinator, PerformerAgent, weighted decision logic, snapshot creation"
      exports: ["Ensemble", "PerformerAgent", "EnsembleSnapshot", "AgentState", "AgentPersonality"]
    - path: "src/score/ensemble.test.ts"
      provides: "Unit tests for ensemble behaviors"
    - path: "src/audio/types.ts"
      provides: "Extended types for ensemble state"
      contains: "PerformerState"
  key_links:
    - from: "src/score/ensemble.ts"
      to: "src/audio/types.ts"
      via: "imports Pattern, ScoreNote types"
      pattern: "import.*types"
    - from: "src/score/ensemble.ts"
      to: "src/score/patterns.ts"
      via: "imports PATTERNS for default score"
      pattern: "import.*PATTERNS"
---

<objective>
Build the ensemble AI core: PerformerAgent with weighted decision-making, Ensemble coordinator with immutable snapshot evaluation, band enforcement, dropout/rejoin cycles, unison seeking, and natural endgame logic.

Purpose: This is the brain of Phase 2 -- pure logic that determines how multiple simulated performers navigate Riley's 53 patterns with emergent, believable musical behavior. All decision logic is testable without audio.

Output: `src/score/ensemble.ts` with fully tested ensemble AI, extended types in `src/audio/types.ts`.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ensemble-ai/02-RESEARCH.md
@src/audio/types.ts
@src/score/performer.ts
@src/score/patterns.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend types and build Ensemble AI with PerformerAgent</name>
  <files>
    src/audio/types.ts
    src/score/ensemble.ts
    src/score/ensemble.test.ts
  </files>
  <action>
**Types (src/audio/types.ts):** Add these types alongside existing ones (do NOT remove existing types):

```typescript
export interface PerformerState {
  id: number;
  patternIndex: number;    // 0-based
  currentPattern: number;  // 1-based (for display)
  status: 'playing' | 'silent' | 'complete';
}

export interface EnsembleEngineState {
  playing: boolean;
  bpm: number;
  performers: PerformerState[];
  ensembleComplete: boolean;
}
```

**Ensemble (src/score/ensemble.ts):** Create the full ensemble AI module. Key components:

1. **EnsembleSnapshot interface** (immutable, frozen each tick):
   - `performers`: ReadonlyArray of {id, patternIndex, status}
   - `minPatternIndex`, `maxPatternIndex`, `averagePatternIndex` (computed from *playing* performers only)
   - `density`: fraction currently playing (0-1)
   - `totalPerformers`: total count

2. **AgentPersonality interface** -- per-agent variation to prevent lockstep:
   - `advanceBias`: 0.8-1.2 multiplier on advance weight
   - `repeatBias`: 0.8-1.2 multiplier on repeat weight
   - `dropoutBias`: 0.8-1.2 multiplier on dropout weight
   - `minSilentBeats`: 4-16 eighth notes minimum silence
   - `maxSilentBeats`: 16-64 eighth notes maximum silence
   - `dropoutCooldown`: 16-48 beats between dropouts

3. **AgentState interface**:
   - id, patternIndex (0-based), noteIndex (within current pattern), repetitionsRemaining
   - status: 'playing' | 'silent' | 'complete'
   - beatsSilent, beatsSinceLastDropout
   - beatsInCurrentNote: tracks position within multi-eighth-note notes
   - personality: AgentPersonality
   - entryDelay: beats to wait before entering (for staggered start)

4. **weightedChoice<T> utility function**: Takes array of {value, weight}, normalizes weights, returns random choice via cumulative distribution.

5. **PerformerAgent class**:
   - Constructor takes (id, patterns, personality). Initializes at pattern 0, note 0, random repetitions 2-8.
   - `tick(snapshot: EnsembleSnapshot): AgentNoteEvent | null` -- called every eighth-note beat:
     - If entryDelay > 0, decrement and return null (staggered entry).
     - If status is 'complete', return null.
     - If status is 'silent', run rejoin logic (see below). Return null.
     - If status is 'playing':
       - If `beatsInCurrentNote > 0`, decrement and return null (sustaining a multi-beat note).
       - Get current note from patterns[patternIndex].notes[noteIndex].
       - Set beatsInCurrentNote = note.duration - 1 (will sustain for remaining beats).
       - Advance noteIndex. If end of pattern notes:
         - Decrement repetitionsRemaining.
         - If repetitions exhausted: run decision logic (advance/repeat/dropout).
         - Reset noteIndex to 0.
       - Return {performerId: id, midi: note.midi, duration: note.duration} or null for rest (midi=0).
   - Decision logic at pattern boundary (called when repetitions exhaust):
     - Compute weights using `computeWeights(agentState, snapshot)`.
     - Apply band enforcement AFTER weighted choice (hard override).
     - Apply endgame logic for patterns near 53.
     - Execute chosen action: advance increments patternIndex and picks new random reps; repeat picks new random reps on same pattern; dropout sets status='silent'.
   - Rejoin logic (each beat while silent):
     - Increment beatsSilent.
     - Rejoin probability increases as silence lengthens past minSilentBeats.
     - Density boost: more likely to rejoin when density < 0.5.
     - Force rejoin at maxSilentBeats.
     - On rejoin: set status='playing', reset beatsSilent, check band position and jump forward if too far behind.
   - `get state(): AgentState` for snapshot creation.
   - `get isComplete(): boolean`
   - `reset()`: back to pattern 0, playing, fresh reps.

6. **computeWeights function**:
   - Base weights: advance=0.3, repeat=0.5, dropout=0.2
   - Near top of band (within 1 of max): advance *= 0.2, repeat *= 2.0
   - Near bottom of band (within 1 of min): advance *= 3.0, repeat *= 0.3
   - High density (> 0.8): dropout *= 2.0
   - Low density (< 0.4): dropout *= 0.3
   - Unison seeking: if 2+ performers on same pattern, repeat *= 2.0; if 2+ one pattern ahead, advance *= 2.0
   - Apply personality biases as multipliers
   - Normalize to sum to 1

7. **enforceBand function**: BAND_WIDTH = 3.
   - If agent is BAND_WIDTH or more ahead of minPatternIndex AND decision is 'advance': force 'repeat'.
   - If agent is BAND_WIDTH or more behind maxPatternIndex: force 'jump' to (maxPatternIndex - 1).
   - Band computed from *playing* performers only (silent performers don't count).

8. **Endgame logic** (patterns 48+):
   - On final pattern (index 52, pattern 53): never advance, only repeat or dropout.
   - Once > 60% of performers are at the final pattern, per-beat dropout chance scales up: `(fractionAtEnd - 0.6) * 2.5 * 0.1`.
   - A performer that drops out on pattern 53 sets status='complete' (permanent, no rejoin).

9. **Ensemble class**:
   - Constructor takes (count: number, patterns: Pattern[]). Creates `count` PerformerAgent instances with random personalities and staggered entry delays (agent 0: delay 0, each subsequent: previous + random 2-4 beats).
   - `tick(): AgentNoteEvent[]` -- creates frozen snapshot, calls tick() on all agents, returns note events.
   - `createSnapshot(): EnsembleSnapshot` -- computes from current agent states. minPatternIndex/maxPatternIndex/averagePatternIndex only from playing performers. density = playing / total.
   - `get isComplete(): boolean` -- all agents complete.
   - `get performerStates(): PerformerState[]` -- for UI consumption.
   - `reset()`: reset all agents.
   - Minimum active performers floor: if density would drop below 2/totalPerformers, suppress dropout decisions. This prevents dropout cascades.

10. **AgentNoteEvent interface**: { performerId: number, midi: number, duration: number }

**Tests (src/score/ensemble.test.ts):** Write tests using Vitest:

- `weightedChoice` returns valid values and respects weights (run 1000 trials, check distribution is not uniform when weights differ)
- `Ensemble` creates N agents with distinct personalities (advanceBias values differ)
- `Ensemble.tick()` returns note events only from playing agents
- Band enforcement: manually set one agent far ahead, verify it cannot advance
- Band enforcement: manually set one agent far behind, verify it jumps forward
- Dropout: force an agent to dropout, verify subsequent ticks return no events for it
- Rejoin: force an agent silent for maxSilentBeats, verify it rejoins
- Endgame: set all agents to pattern 52, verify they eventually all become 'complete' after enough ticks
- Snapshot immutability: verify snapshot.performers is frozen (Object.isFrozen)
- Staggered entry: verify not all agents emit notes on tick 1
- Minimum active floor: with 4 agents, if 3 are silent, the 4th should not drop out

Use `describe`/`it` blocks. Mock Math.random where needed for deterministic tests (use `vi.spyOn(Math, 'random')`).
  </action>
  <verify>
Run `npx vitest run src/score/ensemble.test.ts` -- all tests pass.
Run `npx tsc --noEmit` -- no type errors.
  </verify>
  <done>
Ensemble AI module exists with PerformerAgent, Ensemble coordinator, weighted decisions, band enforcement, dropout/rejoin, unison seeking, endgame logic, and staggered entry. All behaviors covered by passing unit tests. Types extended for ensemble state.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run src/score/ensemble.test.ts` passes all tests
- `npx tsc --noEmit` reports no type errors
- Ensemble can be instantiated with 6-8 agents and tick'd 1000 times without errors
- Band enforcement prevents any agent from being > 3 patterns ahead of the minimum
- Agents eventually all reach 'complete' status after enough ticks
</verification>

<success_criteria>
- Ensemble AI is fully implemented and tested as pure logic (no audio dependency)
- PerformerAgent makes weighted decisions influenced by ensemble state
- Band enforcement, dropout/rejoin, unison seeking, and endgame all function correctly
- Types are extended for ensemble state without breaking existing Phase 1 types
</success_criteria>

<output>
After completion, create `.planning/phases/02-ensemble-ai/02-01-SUMMARY.md`
</output>
