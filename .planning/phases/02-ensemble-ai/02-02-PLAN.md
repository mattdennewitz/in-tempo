---
phase: 02-ensemble-ai
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/audio/scheduler.ts
  - src/audio/voice-pool.ts
  - src/audio/engine.ts
  - src/App.tsx
  - src/components/PatternDisplay.tsx
autonomous: true

must_haves:
  truths:
    - "User starts a performance and hears multiple distinct voices playing different patterns simultaneously"
    - "Performers visibly stay within a 2-3 pattern band of each other"
    - "Performers go silent for stretches then rejoin, creating natural breathing"
    - "Performance ends with performers dropping out one by one until silence"
    - "UI shows per-performer status (pattern number and playing/silent state)"
  artifacts:
    - path: "src/audio/scheduler.ts"
      provides: "Beat-clock scheduler polling Ensemble per eighth-note tick"
      exports: ["Scheduler"]
    - path: "src/audio/voice-pool.ts"
      provides: "Scaled voice pool supporting N performers"
      exports: ["VoicePool"]
    - path: "src/audio/engine.ts"
      provides: "AudioEngine managing Ensemble lifecycle and exposing EnsembleEngineState"
      exports: ["AudioEngine"]
    - path: "src/App.tsx"
      provides: "React app wired to ensemble state"
    - path: "src/components/PatternDisplay.tsx"
      provides: "Per-performer pattern display"
  key_links:
    - from: "src/audio/scheduler.ts"
      to: "src/score/ensemble.ts"
      via: "imports Ensemble, calls tick() per beat"
      pattern: "import.*Ensemble"
    - from: "src/audio/engine.ts"
      to: "src/audio/scheduler.ts"
      via: "creates Scheduler with Ensemble"
      pattern: "new Scheduler"
    - from: "src/audio/engine.ts"
      to: "src/score/ensemble.ts"
      via: "creates Ensemble, reads performerStates"
      pattern: "new Ensemble"
    - from: "src/App.tsx"
      to: "src/audio/engine.ts"
      via: "reads EnsembleEngineState for UI rendering"
      pattern: "engine.*getState"
---

<objective>
Refactor the Scheduler to a fixed eighth-note beat clock that polls the Ensemble each tick, scale the VoicePool for multiple performers, update the AudioEngine facade to manage the Ensemble lifecycle, and wire the multi-performer state to the React UI.

Purpose: This integrates the ensemble AI (Plan 01) with the audio engine (Phase 1), producing the full multi-performer playback experience. The scheduler becomes a beat clock, voice pool scales to 2 voices per performer, and the UI shows all performers' states.

Output: Working multi-performer In C performance with ensemble AI driving all musical decisions.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ensemble-ai/02-RESEARCH.md
@.planning/phases/02-ensemble-ai/02-01-SUMMARY.md
@src/audio/scheduler.ts
@src/audio/engine.ts
@src/audio/voice-pool.ts
@src/audio/types.ts
@src/score/ensemble.ts
@src/App.tsx
@src/components/PatternDisplay.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor Scheduler to beat clock and scale VoicePool</name>
  <files>
    src/audio/scheduler.ts
    src/audio/voice-pool.ts
  </files>
  <action>
**Scheduler refactoring (src/audio/scheduler.ts):**

Replace the single-performer, variable-duration scheduler with a fixed eighth-note beat clock that polls the Ensemble.

Key changes:
1. Remove the `performer: Performer` dependency. Replace with `ensemble: Ensemble` import.
2. Constructor now takes `(audioContext, voicePool, ensemble)`.
3. The tick loop advances by exactly one eighth-note duration each step (not by note duration).
4. Each tick: call `ensemble.tick()` which returns `AgentNoteEvent[]`. For each event with midi > 0:
   - Claim a voice from the pool (using performer-aware claiming -- see below).
   - Send noteOn with frequency via `midiToFrequency(event.midi)`.
   - Schedule noteOff after `event.duration` eighth notes (in seconds: `event.duration * secondsPerEighth`).
5. `advanceTime()` now always advances by exactly 1 eighth note: `nextNoteTime += secondsPerEighth`.
6. `getState()` returns `EnsembleEngineState` (not `EngineState`):
   ```typescript
   getState(): EnsembleEngineState {
     return {
       playing: this._playing,
       bpm: this._bpm,
       performers: this.ensemble.performerStates,
       ensembleComplete: this.ensemble.isComplete,
     };
   }
   ```
7. `onStateChange` type changes to `((state: EnsembleEngineState) => void) | null`.
8. The stop-on-completion check: after calling `ensemble.tick()`, if `ensemble.isComplete`, call `this.stop()`.
9. `reset()` now calls `this.ensemble.reset()` instead of `this.performer.reset()`.

**Voice management per performer:**

For scheduling note releases, each AgentNoteEvent includes performerId. Use the performerId to track which voice belongs to which performer. Maintain a `Map<number, {voiceIndex: number, releaseTimer}>` keyed by performerId so that:
- When performer N plays a new note, if they already have an active voice, cancel the old release timer and reuse the voice (send noteOff then noteOn) OR let voice stealing handle it.
- Simpler approach: just use the global claim/release. Since each performer plays one note at a time and notes have release timers, the pool handles contention naturally. The pool size (2 * performerCount) gives enough headroom.

Keep the existing release timer pattern from Phase 1 but adapt it: the release timer key should be the voice index (same as before). Multiple performers will have concurrent release timers -- this is fine since each timer references a specific voice index.

**VoicePool (src/audio/voice-pool.ts):**

No structural changes needed -- the VoicePool already supports arbitrary size via constructor parameter. The scaling happens in `engine.ts` where pool size is set to `performerCount * 2`. However, verify the VoicePool handles 16 voices cleanly (it should, since it's index-based).

One improvement: add a `get size(): number` getter that returns `this.voices.length` for debugging/verification.
  </action>
  <verify>
`npx tsc --noEmit` -- no type errors.
The Scheduler compiles with the new Ensemble-based API.
  </verify>
  <done>
Scheduler operates as a fixed eighth-note beat clock polling Ensemble.tick() each beat. VoicePool scales to N*2 voices. Note events from all performers are scheduled correctly with release timers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update AudioEngine facade and wire ensemble state to React UI</name>
  <files>
    src/audio/engine.ts
    src/App.tsx
    src/components/PatternDisplay.tsx
  </files>
  <action>
**AudioEngine (src/audio/engine.ts):**

Update to manage Ensemble lifecycle:

1. Add imports: `Ensemble` from `../score/ensemble.ts`, `EnsembleEngineState` from `./types.ts`.
2. Remove `Performer` import and `performer` field.
3. Add `ensemble: Ensemble | null = null` field.
4. Default performer count: `private performerCount = 8`.
5. In `initialize()`:
   - Create ensemble: `this.ensemble = new Ensemble(this.performerCount, PATTERNS)`.
   - Scale voice pool: `this.voicePool = new VoicePool(this.audioContext, this.performerCount * 2)`.
   - Create scheduler: `this.scheduler = new Scheduler(this.audioContext, this.voicePool, this.ensemble)`.
6. `getState()` returns `EnsembleEngineState`:
   ```typescript
   getState(): EnsembleEngineState {
     return this.scheduler?.getState() ?? {
       playing: false,
       bpm: 120,
       performers: [],
       ensembleComplete: false,
     };
   }
   ```
7. `onStateChange` type: `((state: EnsembleEngineState) => void) | null`.
8. `dispose()`: clean up ensemble reference.
9. `reset()`: scheduler.reset() handles ensemble.reset() internally.

**PatternDisplay (src/components/PatternDisplay.tsx):**

Replace single-pattern display with per-performer status list:

```typescript
import type { PerformerState } from '../audio/types.ts';

interface PatternDisplayProps {
  performers: PerformerState[];
  playing: boolean;
  ensembleComplete: boolean;
  totalPatterns: number;
}

export function PatternDisplay({ performers, playing, ensembleComplete, totalPatterns }: PatternDisplayProps) {
  if (ensembleComplete) {
    return (
      <div className="pattern-display">
        <span className="pattern-text">Performance Complete</span>
      </div>
    );
  }

  if (!playing && performers.length === 0) {
    return (
      <div className="pattern-display">
        <span className="pattern-text">Ready</span>
      </div>
    );
  }

  return (
    <div className="pattern-display">
      <div className="performer-grid">
        {performers.map((p) => (
          <div key={p.id} className={`performer-status performer-status--${p.status}`}>
            <span className="performer-id">P{p.id + 1}</span>
            <span className="performer-pattern">
              {p.status === 'complete' ? 'Done' : p.status === 'silent' ? '...' : `${p.currentPattern}`}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

Add CSS in App.css for the performer grid:
- `.performer-grid`: CSS grid, 4 columns on desktop, gap 8px
- `.performer-status`: small card showing performer ID and pattern number
- `.performer-status--playing`: normal opacity
- `.performer-status--silent`: reduced opacity (0.4)
- `.performer-status--complete`: even more reduced opacity (0.2), strikethrough or dimmed

**App.tsx:**

Update state and props to use ensemble state:

1. Replace `currentPattern` state with `performers` (PerformerState[]) and `ensembleComplete` (boolean).
2. `onStateChange` callback reads `state.performers` and `state.ensembleComplete`.
3. Pass `performers`, `ensembleComplete`, and `playing` to PatternDisplay.
4. Import `EnsembleEngineState` and `PerformerState` types.
5. Remove `TOTAL_PATTERNS` import from patterns.ts (PatternDisplay no longer needs it -- or keep it and pass it, either works).

Keep Transport and BpmSlider unchanged -- they still work with start/stop/reset/setBpm.
  </action>
  <verify>
`npx tsc --noEmit` -- no type errors.
`npm run dev` -- app starts without console errors.
Start a performance: multiple performers should be visible in the UI with pattern numbers updating.
Performers should show playing/silent states changing over time.
Performance should eventually end with all performers showing 'Done'.
  </verify>
  <done>
AudioEngine creates and manages an 8-performer Ensemble. Scheduler polls all performers per beat. UI displays per-performer pattern numbers and playing/silent/complete states. Starting a performance produces audible multi-voice ensemble playback with ensemble AI driving all musical decisions. Performance ends naturally as performers reach pattern 53 and drop out.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` reports no type errors across the project
- `npm run dev` starts the application without errors
- Starting a performance produces audible multi-voice playback (multiple distinct melodic lines)
- PatternDisplay shows 8 performers with pattern numbers that update independently
- Performers show 'silent' state periodically (dropout behavior visible)
- No performer pattern number exceeds another by more than 3
- After sufficient time, all performers reach 'Done' and performance stops
- Reset returns all performers to initial state
- BPM changes affect all performers' tempo simultaneously
</verification>

<success_criteria>
- Multiple performers play simultaneously with distinct pattern positions
- Ensemble AI decisions are audible: varying density, dropouts, unison clustering
- UI reflects per-performer state in real time
- Performance ends naturally with staggered dropouts
- All Phase 1 controls (start, stop, reset, BPM) continue to work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-ensemble-ai/02-02-SUMMARY.md`
</output>
