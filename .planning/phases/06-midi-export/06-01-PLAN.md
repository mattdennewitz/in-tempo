---
phase: 06-midi-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/audio/midi-recorder.ts
  - src/audio/midi-exporter.ts
  - src/audio/scheduler.ts
  - src/audio/engine.ts
  - src/audio/types.ts
autonomous: true

must_haves:
  truths:
    - "Performance note events are recorded with integer beat timing during playback"
    - "Recording starts automatically with playback and stops when playback stops"
    - "Recorded events can be converted to a multi-track MIDI file with correct pitches, durations, velocities, tempo, and instrument assignments"
    - "Engine exposes exportMidi() and hasRecording for UI consumption"
  artifacts:
    - path: "src/audio/midi-recorder.ts"
      provides: "Passive event recorder with integer beat counter"
      exports: ["MidiRecorder", "RecordedEvent"]
    - path: "src/audio/midi-exporter.ts"
      provides: "MIDI file generation and browser download"
      exports: ["exportToMidi", "downloadMidi"]
    - path: "src/audio/scheduler.ts"
      provides: "Beat counter and recording calls in scheduleBeat"
      contains: "beatCounter"
    - path: "src/audio/engine.ts"
      provides: "exportMidi() and hasRecording facade methods"
      contains: "exportMidi"
  key_links:
    - from: "src/audio/scheduler.ts"
      to: "src/audio/midi-recorder.ts"
      via: "midiRecorder.record() called in scheduleBeat loop"
      pattern: "midiRecorder.*record"
    - from: "src/audio/midi-exporter.ts"
      to: "midi-writer-js"
      via: "MidiWriter.Track, NoteEvent, ProgramChangeEvent, Writer"
      pattern: "MidiWriter"
    - from: "src/audio/engine.ts"
      to: "src/audio/midi-exporter.ts"
      via: "exportToMidi() called from exportMidi()"
      pattern: "exportToMidi"
---

<objective>
Create the MIDI recording and export pipeline: a MidiRecorder that passively captures note events during playback using an integer beat counter, a MidiExporter that converts recorded events to multi-track MIDI files via midi-writer-js, and wire both into the existing Scheduler and Engine.

Purpose: This is the core backend for MIDI export -- recording events and converting them to .mid format. The UI (Plan 02) will call Engine.exportMidi() to trigger download.
Output: Four files: two new (midi-recorder.ts, midi-exporter.ts), two modified (scheduler.ts, engine.ts). npm dependency: midi-writer-js.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-midi-export/06-RESEARCH.md
@src/audio/scheduler.ts
@src/audio/engine.ts
@src/audio/types.ts
@src/audio/sampler.ts
@src/score/ensemble.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install midi-writer-js and create MidiRecorder + MidiExporter</name>
  <files>
    src/audio/midi-recorder.ts
    src/audio/midi-exporter.ts
    package.json
  </files>
  <action>
    1. Install midi-writer-js: `npm install midi-writer-js`

    2. Create `src/audio/midi-recorder.ts`:
       - Export interface `RecordedEvent` with fields: `beatIndex: number` (integer eighth-note count from start), `performerId: number`, `midi: number`, `duration: number` (in eighth notes), `velocity: number` (0.3-1.0 InTempo range).
       - Export class `MidiRecorder` with:
         - Private `events: RecordedEvent[]`, `_isRecording: boolean`, `_stopBeat: number | null`
         - `start()`: clears events array, sets `_isRecording = true`, `_stopBeat = null`
         - `record(beatIndex, performerId, midi, duration, velocity)`: pushes to events if recording
         - `stop(currentBeat: number): RecordedEvent[]`: sets `_isRecording = false`, sets `_stopBeat = currentBeat`, returns events filtered to `beatIndex < currentBeat` (trims ghost notes from lookahead)
         - `getEvents(): RecordedEvent[]`: returns current events (for mid-playback export snapshot), filtered to `_stopBeat` if set
         - `clear()`: resets all state
         - Getters: `isRecording: boolean`, `eventCount: number`

    3. Create `src/audio/midi-exporter.ts`:
       - Import `MidiWriter` from `midi-writer-js`. Import `RecordedEvent` from `./midi-recorder.ts`. Import `assignInstrument` from `./sampler.ts`. Import `InstrumentType` from `./types.ts`.
       - Constants: `TICKS_PER_EIGHTH = 64` (midi-writer-js PPQ=128, eighth = PPQ/2)
       - `GM_PROGRAMS: Record<InstrumentType, number>` mapping: piano -> 0, marimba -> 12, synth -> 88 (0-indexed GM program numbers)
       - Export function `exportToMidi(events: RecordedEvent[], bpm: number): Uint8Array`:
         - Group events by performerId into a Map
         - For each performer (iterate in sorted performerId order for deterministic output):
           - Create a `new MidiWriter.Track()`
           - On first track only: `track.setTempo(bpm)`
           - Get instrument via `assignInstrument(performerId)`
           - `track.addTrackName(\`Performer ${performerId + 1} (${instrument})\`)`
           - Add `new MidiWriter.ProgramChangeEvent({ instrument: GM_PROGRAMS[instrument] })`
           - Sort performer events by beatIndex
           - For each event: convert velocity `Math.max(1, Math.round(evt.velocity * 100))` (midi-writer-js uses 1-100, NOT 0-127), create `new MidiWriter.NoteEvent({ pitch: evt.midi, duration: \`T${evt.duration * TICKS_PER_EIGHTH}\`, velocity: mwjVelocity, startTick: evt.beatIndex * TICKS_PER_EIGHTH })`
           - Add NoteEvent to track
         - Create `new MidiWriter.Writer(tracks)` and return `writer.buildFile()`
       - Export function `downloadMidi(data: Uint8Array, filename: string): void`:
         - Create Blob with type 'audio/midi', create object URL, create `<a>` element with download attribute, click it, remove element, revoke URL

       IMPORTANT midi-writer-js API notes (from research):
       - Use `startTick` (not `tick`) for absolute tick positioning -- check the actual API. The research says `tick` but verify the NoteEvent constructor accepts it. If the API uses `startTick`, use that. If neither works, compute delta times manually between sorted events.
       - Velocity is 1-100 scale, NOT 0-127
       - Duration `T{n}` format for direct tick counts
       - `buildFile()` returns Uint8Array
  </action>
  <verify>
    - `npm ls midi-writer-js` shows installed version
    - `npx tsc --noEmit` passes (no type errors)
    - Both files export their expected symbols
  </verify>
  <done>
    MidiRecorder class records events with integer beat indices and trims ghost notes on stop. MidiExporter converts recorded events to multi-track MIDI with correct GM programs, tempo, velocity scaling (1-100), and browser download. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire MidiRecorder into Scheduler and expose on Engine</name>
  <files>
    src/audio/scheduler.ts
    src/audio/engine.ts
  </files>
  <action>
    1. Modify `src/audio/scheduler.ts`:
       - Import `MidiRecorder` from `./midi-recorder.ts`
       - Add private field `beatCounter: number = 0`
       - Add public field `midiRecorder: MidiRecorder | null = null` (set by Engine, same pattern as velocityConfigRef)
       - In `start()`: reset `this.beatCounter = 0`, call `this.midiRecorder?.start()`
       - In `scheduleBeat()`, inside the existing `for (const event of events)` loop, AFTER the existing `if (event.midi === 0) continue;` check and AFTER routing to audio (synth/sampler), add:
         ```
         if (this.midiRecorder?.isRecording) {
           this.midiRecorder.record(
             this.beatCounter,
             event.performerId,
             event.midi,
             event.duration,
             event.velocity,
           );
         }
         ```
       - AFTER the for loop (and after the pulse scheduling), increment: `this.beatCounter++`
       - In `stop()`: call `this.midiRecorder?.stop(this.beatCounter)` to trim ghost notes
       - In `reset()`: call `this.midiRecorder?.clear()` and reset `this.beatCounter = 0`
       - In `getState()`: add `hasRecording: (this.midiRecorder?.eventCount ?? 0) > 0` to the returned state object

    2. Modify `src/audio/types.ts`:
       - Add `hasRecording: boolean` to the `EnsembleEngineState` interface

    3. Modify `src/audio/engine.ts`:
       - Import `MidiRecorder` from `./midi-recorder.ts`
       - Import `exportToMidi, downloadMidi` from `./midi-exporter.ts`
       - Add private field `midiRecorder: MidiRecorder = new MidiRecorder()`
       - In `initialize()`, after creating scheduler: `this.scheduler.midiRecorder = this.midiRecorder`
       - In `setPerformerCount()` where scheduler is rebuilt: re-assign `this.scheduler.midiRecorder = this.midiRecorder`
       - In `setScoreMode()` where scheduler is rebuilt: re-assign `this.scheduler.midiRecorder = this.midiRecorder`
       - Add method `exportMidi(): void`:
         - Get events: if playing, use `this.midiRecorder.getEvents()`, else use `this.midiRecorder.getEvents()`
         - If no events (length === 0), return early (nothing to export)
         - Get BPM from `this.scheduler?.getState().bpm ?? 120`
         - Call `const data = exportToMidi(events, bpm)`
         - Generate filename: `intempo-${this.currentMode}-${bpm}bpm-${new Date().toISOString().slice(0,19).replace(/[T:]/g, '-')}.mid`
         - Call `downloadMidi(data, filename)`
       - Add getter `hasRecording(): boolean`: returns `this.midiRecorder.eventCount > 0`
       - In the fallback state returned by `getState()` (when scheduler is null): add `hasRecording: false`
       - In `dispose()`: call `this.midiRecorder.clear()`
       - In `reset()`: call `this.midiRecorder.clear()` (so reset clears recorded data)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `grep -n "beatCounter" src/audio/scheduler.ts` shows beat counter in start, scheduleBeat, and reset
    - `grep -n "exportMidi\|hasRecording\|midiRecorder" src/audio/engine.ts` shows all three
  </verify>
  <done>
    Scheduler records every note event with integer beat timing during playback and trims on stop. Engine owns the MidiRecorder, passes it to Scheduler, and exposes exportMidi() (triggers download) and hasRecording (for UI enable/disable). Recording starts automatically with playback. Reset clears recorded data.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm ls midi-writer-js` shows ^3.1.1 installed
- MidiRecorder correctly accumulates events and trims at stop beat
- MidiExporter produces valid multi-track MIDI with tempo, GM programs, and scaled velocities
- Engine.exportMidi() generates and downloads a .mid file
- Engine.hasRecording returns true after playback has produced events
</verification>

<success_criteria>
- midi-writer-js installed and importable
- MidiRecorder records events with integer beat indices, trims ghost notes on stop
- MidiExporter converts to multi-track MIDI with: one track per performer, GM program changes (piano=0, marimba=12, synth=88), tempo meta-event, velocity mapped to 1-100 scale, Tn duration format
- Scheduler increments beatCounter per eighth note, calls midiRecorder.record() for every note event, starts/stops/clears recorder with playback lifecycle
- Engine exposes exportMidi() and hasRecording, manages MidiRecorder lifecycle across scheduler rebuilds
- Full codebase compiles with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-midi-export/06-01-SUMMARY.md`
</output>
