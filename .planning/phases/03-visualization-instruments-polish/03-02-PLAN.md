---
phase: 03-visualization-instruments-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/audio/sampler.ts
  - src/audio/pulse.ts
  - src/audio/types.ts
  - src/audio/scheduler.ts
  - src/audio/engine.ts
autonomous: true

must_haves:
  truths:
    - "Some performers play sampled instrument sounds (piano, marimba) while others play synth -- the mix is audibly varied"
    - "A steady eighth-note pulse on high C is toggleable by the user"
    - "Sampled instruments load during initialization, not lazily per-note"
  artifacts:
    - path: "src/audio/sampler.ts"
      provides: "SamplePlayer using smplr library for piano and marimba playback"
      exports: ["SamplePlayer"]
    - path: "src/audio/pulse.ts"
      provides: "Pulse generator for high C eighth notes"
      exports: ["PulseGenerator"]
    - path: "src/audio/types.ts"
      provides: "InstrumentType and instrument field on PerformerState"
      contains: "InstrumentType"
  key_links:
    - from: "src/audio/scheduler.ts"
      to: "src/audio/sampler.ts"
      via: "routes sampled performer notes through SamplePlayer instead of VoicePool"
      pattern: "samplePlayer"
    - from: "src/audio/scheduler.ts"
      to: "src/audio/pulse.ts"
      via: "schedules pulse note each beat when enabled"
      pattern: "pulse"
    - from: "src/audio/engine.ts"
      to: "src/audio/sampler.ts"
      via: "creates and initializes SamplePlayer during engine init"
      pattern: "SamplePlayer"
---

<objective>
Sampled instrument integration (piano, marimba via smplr library) and toggleable eighth-note pulse on high C.

Purpose: Create audible variety in the ensemble by assigning different instrument types to performers, and provide the traditional "In C" pulse reference tone that performers can align to.

Output: SamplePlayer for sampled instruments, PulseGenerator for the high C pulse, scheduler routing logic, engine initialization.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-visualization-instruments-polish/03-RESEARCH.md
@.planning/phases/02-ensemble-ai/02-02-SUMMARY.md

Key existing files:
@src/audio/engine.ts (AudioEngine facade -- needs SamplePlayer + Pulse init)
@src/audio/scheduler.ts (scheduleBeat -- needs instrument routing + pulse scheduling)
@src/audio/voice-pool.ts (existing synth voice pool -- unchanged)
@src/audio/types.ts (needs InstrumentType addition)
@src/score/ensemble.ts (Ensemble -- needs instrument assignment on agents)
@package.json (needs smplr dependency)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SamplePlayer with smplr and PulseGenerator</name>
  <files>
    src/audio/sampler.ts
    src/audio/pulse.ts
    src/audio/types.ts
    package.json
  </files>
  <action>
Install smplr: `npm install smplr`

Update `src/audio/types.ts`:
- Add `export type InstrumentType = 'synth' | 'piano' | 'marimba';`
- Add `instrument: InstrumentType` field to `PerformerState` interface.
- Add `instrument` to `AgentNoteEvent` in ensemble types if needed (or handle via performer ID lookup in scheduler).

Create `src/audio/sampler.ts`:
- `SamplePlayer` class wrapping smplr library.
- Constructor takes `AudioContext`.
- `async initialize(): Promise<void>` -- loads piano using `SplendidGrandPiano` from smplr and marimba using `Soundfont` from smplr with `{ instrument: 'marimba' }`. Both connect to a `GainNode` (masterGain) that connects to `audioContext.destination`. Set masterGain to ~0.6 to balance with synth voices.
- `play(instrument: 'piano' | 'marimba', midi: number, time: number, duration: number): void` -- schedules a note on the appropriate smplr instrument. Use the smplr `start()` API with `{ note: midi, time: time, duration: duration }`.
- `get isReady(): boolean` -- returns true when all instruments are loaded.
- `dispose(): void` -- clean up smplr instances.
- Export `assignInstrument(performerId: number): InstrumentType` function -- deterministic assignment: `['synth', 'piano', 'marimba'][performerId % 3]` so ~33% each. This ensures variety without randomness (stable across reset).

Create `src/audio/pulse.ts`:
- `PulseGenerator` class.
- Constructor takes `AudioContext`.
- Creates a dedicated `GainNode` connected to `audioContext.destination` with gain ~0.08 (subtle pulse).
- `schedulePulse(time: number, duration: number): void` -- creates an `OscillatorNode` with frequency for MIDI 96 (C7, high C = 2093.005 Hz), type 'sine'. Connects to the gain node. Starts at `time`, stops at `time + duration * 0.5` (short staccato pulse). The oscillator auto-disposes after stopping.
- `set enabled(value: boolean)` and `get enabled(): boolean` -- toggle property.
- `dispose(): void` -- disconnect gain node.
  </action>
  <verify>
`npx tsc --noEmit` passes. `npm install` shows smplr added to dependencies. SamplePlayer exports are importable. PulseGenerator exports are importable. InstrumentType is exported from types.ts.
  </verify>
  <done>SamplePlayer wraps smplr for piano and marimba playback. PulseGenerator creates staccato high-C oscillator pulses. InstrumentType added to type system. Instrument assignment is deterministic by performer ID.</done>
</task>

<task type="auto">
  <name>Task 2: Wire SamplePlayer and PulseGenerator into Scheduler and Engine</name>
  <files>
    src/audio/scheduler.ts
    src/audio/engine.ts
    src/score/ensemble.ts
  </files>
  <action>
Update `src/audio/scheduler.ts`:
- Add `SamplePlayer` and `PulseGenerator` to constructor parameters (or set via property after construction).
- Import `assignInstrument` from `./sampler.ts`.
- In `scheduleBeat()`, for each event:
  - Determine instrument via `assignInstrument(event.performerId)`.
  - If instrument is `'synth'`: use existing VoicePool path (claim, noteOn, schedule release).
  - If instrument is `'piano'` or `'marimba'`: call `samplePlayer.play(instrument, event.midi, time, noteDurationSeconds)`. No voice pool claim needed -- smplr handles its own voices.
- After processing performer events, if `pulseGenerator.enabled`, call `pulseGenerator.schedulePulse(time, secondsPerEighth)`.
- Add `togglePulse(): boolean` method that toggles pulse enabled state and returns new state.
- Update `getState()` to include `pulseEnabled: boolean`.

Update `src/audio/types.ts`:
- Add `pulseEnabled: boolean` to `EnsembleEngineState`.

Update `src/audio/engine.ts`:
- Import `SamplePlayer` and `PulseGenerator`.
- In `initialize()`:
  - Create `SamplePlayer` with audioContext and call `await samplePlayer.initialize()` (loads samples from CDN).
  - Create `PulseGenerator` with audioContext.
  - Pass both to Scheduler constructor (or set as properties).
- Add `togglePulse(): boolean` method that delegates to scheduler.
- In `dispose()`: call `samplePlayer.dispose()` and `pulseGenerator.dispose()`.
- Connect SamplePlayer's master gain to `audioContext.destination` (or the same master gain that VoicePool uses).

Update `src/score/ensemble.ts`:
- In `performerStates` getter, add `instrument: assignInstrument(s.id)` to each performer state object returned. Import `assignInstrument` from `../audio/sampler.ts`.
  </action>
  <verify>
`npx tsc --noEmit` passes. `npm run build` succeeds. The scheduler routes synth notes to VoicePool and sampled notes to SamplePlayer. Pulse scheduling occurs each beat when enabled. Engine initializes SamplePlayer (loads from CDN) before playback starts.
  </verify>
  <done>Scheduler routes performer notes to synth VoicePool or SamplePlayer based on instrument assignment. Pulse generator fires each eighth note when enabled. Engine manages lifecycle of both new audio components. Sample loading happens during init (no first-note latency).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors
2. `npm run build` -- production build succeeds
3. Start performance: hear a mix of synth and sampled (piano/marimba) voices
4. Performers 0, 3, 6 play synth; 1, 4, 7 play piano; 2, 5 play marimba (deterministic)
5. Toggle pulse: hear steady eighth-note high C clicks
6. Toggle pulse off: clicks stop
7. Stop/reset: all instruments silence correctly
</verification>

<success_criteria>
- Ensemble performance has audibly varied timbres (synth + piano + marimba)
- Sampled instruments load during init, no latency on first notes
- Pulse is a subtle, steady eighth-note high C that can be toggled on/off
- All existing transport controls (start/stop/reset/BPM) work correctly with new instruments
- No audio clipping or distortion with mixed instrument types
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualization-instruments-polish/03-02-SUMMARY.md`
</output>
