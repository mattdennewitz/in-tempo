---
phase: 03-visualization-instruments-polish
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/score/ensemble.ts
  - src/audio/voice-pool.ts
  - src/audio/engine.ts
  - src/audio/types.ts
  - src/App.tsx
  - src/App.css
  - src/components/PerformerControls.tsx
autonomous: true

must_haves:
  truths:
    - "User can add a performer during a running performance and hear/see the new performer immediately"
    - "User can remove a performer during a running performance and hear/see the change immediately"
    - "Added performers start at the current ensemble minimum pattern so they blend in"
    - "Performer IDs are monotonically increasing and never reused"
    - "Removing a performer while scheduler is ticking does not cause array mutation errors"
  artifacts:
    - path: "src/score/ensemble.ts"
      provides: "addAgent() and removeAgent() methods with mutation queueing"
      contains: "addAgent"
    - path: "src/audio/voice-pool.ts"
      provides: "resize() method for growing the pool dynamically"
      contains: "resize"
    - path: "src/components/PerformerControls.tsx"
      provides: "Add/remove performer buttons"
    - path: "src/audio/engine.ts"
      provides: "addPerformer() and removePerformer() public API"
      contains: "addPerformer"
  key_links:
    - from: "src/App.tsx"
      to: "src/audio/engine.ts"
      via: "calls engine.addPerformer() and engine.removePerformer()"
      pattern: "addPerformer|removePerformer"
    - from: "src/audio/engine.ts"
      to: "src/score/ensemble.ts"
      via: "delegates to ensemble.addAgent() / removeAgent()"
      pattern: "addAgent|removeAgent"
    - from: "src/audio/engine.ts"
      to: "src/audio/voice-pool.ts"
      via: "calls voicePool.resize() when performer count changes"
      pattern: "resize"
---

<objective>
Dynamic performer management: add and remove performers during a running performance with immediate audio and visual feedback.

Purpose: Let the user sculpt the ensemble in real-time by adding new performers who blend into the current musical context, or removing performers to thin the texture. The ensemble size is no longer fixed at 8.

Output: Ensemble addAgent/removeAgent with safe mutation queueing, VoicePool dynamic resize, engine API, UI controls.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-visualization-instruments-polish/03-RESEARCH.md
@.planning/phases/03-visualization-instruments-polish/03-01-SUMMARY.md
@.planning/phases/03-visualization-instruments-polish/03-02-SUMMARY.md

Key existing files (as modified by 03-01 and 03-02):
@src/score/ensemble.ts (Ensemble class -- needs addAgent/removeAgent)
@src/audio/voice-pool.ts (VoicePool -- needs resize)
@src/audio/engine.ts (AudioEngine -- needs addPerformer/removePerformer)
@src/audio/types.ts (EnsembleEngineState -- may need performerCount)
@src/App.tsx (needs PerformerControls wiring)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dynamic agent management to Ensemble and VoicePool resize</name>
  <files>
    src/score/ensemble.ts
    src/audio/voice-pool.ts
  </files>
  <action>
Update `src/score/ensemble.ts`:
- Add `private nextId: number` field, initialized in constructor to `count` (so IDs 0 through count-1 are taken, next is `count`).
- Add `addAgent(): number` method:
  - Create a new PerformerAgent with id = `this.nextId++` and the ensemble's patterns.
  - Set the new agent's patternIndex to the current ensemble minimum pattern (from a snapshot) so it blends in.
  - Set entryDelay to `Math.floor(Math.random() * 3) + 2` beats (2-4 beats stagger).
  - Push to agents array.
  - Return the new agent's id.
- Add `removeAgent(id: number): boolean` method:
  - Find the agent by id. If not found, return false.
  - Mark agent as 'complete' status first (so its voice releases naturally on next tick).
  - Queue the actual splice for next `tick()` call using a `private pendingRemovals: Set<number>` field.
  - Return true.
- In `tick()` method, at the START (before creating snapshot), process `pendingRemovals`:
  - Filter out any agents whose id is in pendingRemovals.
  - Clear pendingRemovals.
  - This ensures no array mutation during iteration.
- Add `get agentCount(): number` returning `this.agents.length`.
- Update `reset()` to also reset `nextId` to current agent count and clear pendingRemovals.

Update `src/audio/voice-pool.ts`:
- Add `resize(newSize: number): void` method:
  - If newSize > current size: create additional AudioWorkletNode instances, connect them to masterGain, add their indices to available set. This requires the AudioContext, so store it as a private field in constructor.
  - If newSize < current size: mark excess voices for removal but DO NOT disconnect any currently claimed voices. Only remove from available pool. Actual node cleanup happens when all excess voices are released.
  - Update masterGain value: `Math.min(1.0, 2.5 / newSize)`.
- Store `audioContext` as private field (currently not stored -- add to constructor).
  </action>
  <verify>
`npx tsc --noEmit` passes. Ensemble has addAgent() returning a number. removeAgent() returns boolean. VoicePool has resize() method. No direct array mutation during tick().
  </verify>
  <done>Ensemble supports adding agents with monotonically increasing IDs starting at current ensemble minimum pattern. Removal is queued and applied between ticks (no mid-iteration mutation). VoicePool can grow dynamically by creating new AudioWorkletNodes.</done>
</task>

<task type="auto">
  <name>Task 2: Wire dynamic management through Engine to UI</name>
  <files>
    src/audio/engine.ts
    src/audio/types.ts
    src/components/PerformerControls.tsx
    src/App.tsx
    src/App.css
  </files>
  <action>
Update `src/audio/engine.ts`:
- Add `addPerformer(): number | null` method:
  - If not initialized, return null.
  - Call `ensemble.addAgent()` to get new id.
  - Call `voicePool.resize(ensemble.agentCount * 2)` to grow pool (2x headroom).
  - Fire state change.
  - Return the new performer id.
- Add `removePerformer(id: number): boolean` method:
  - If not initialized, return false.
  - Call `ensemble.removeAgent(id)`.
  - Voice pool does NOT shrink (excess voices just stay available -- avoids glitches).
  - Fire state change.
  - Return result.
- Add `get performerCount(): number` returning ensemble agent count (or 8 if not initialized).

Update `src/audio/types.ts`:
- Add `performerCount: number` to `EnsembleEngineState` if not already present (helpful for UI).

Create `src/components/PerformerControls.tsx`:
- Component accepting props: `{ onAdd: () => void, onRemove: (id: number) => void, performers: PerformerState[], disabled: boolean }`.
- Render two buttons: "+" (add performer) and "-" (remove last active performer).
- The "-" button removes the performer with the HIGHEST id that is not 'complete'. If no such performer exists (or only 2 remain playing), disable the "-" button.
- Minimum ensemble size enforced in UI: disable "-" when only 2 performers remain.
- Maximum ensemble size: disable "+" when 16 performers reached (reasonable upper bound).
- Styled with palette: salmon accent on "+", muted on "-", consistent with Transport button styling.

Update `src/App.tsx`:
- Import PerformerControls.
- Add `handleAddPerformer` callback that calls `engineRef.current.addPerformer()`.
- Add `handleRemovePerformer` callback that calls `engineRef.current.removePerformer(id)`.
- Place PerformerControls in the controls area alongside Transport and BpmSlider.
- PerformerControls receives `performers` state for determining which performer to remove.

Update `src/App.css`:
- Add styles for `.performer-controls` container and its buttons, matching palette.
  </action>
  <verify>
`npx tsc --noEmit` passes. `npm run build` succeeds. Run `npm run dev`:
1. Start performance with 8 performers.
2. Click "+" -- see a 9th performer appear on Canvas with a new pattern number near the ensemble minimum.
3. Hear the new performer's instrument (determined by its ID % 3).
4. Click "-" -- see the last performer disappear and its audio stop.
5. Minimum of 2 performers enforced (button disables).
6. Stop/reset works correctly with changed performer count.
  </verify>
  <done>Users can dynamically add and remove performers during playback. New performers blend into the current musical position. Removal is safe (queued between ticks). VoicePool grows as needed. UI shows +/- controls with min/max bounds.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors
2. `npm run build` -- production build succeeds
3. Add performer during playback: new performer appears on Canvas and is audible within a few beats
4. Remove performer during playback: performer disappears and its audio stops
5. Add up to 16 performers: "+" button disables at max
6. Remove down to 2 performers: "-" button disables at min
7. Reset after adding/removing: ensemble resets to current performer count
8. No audio glitches when adding (VoicePool grows smoothly)
9. No array errors when removing (mutations queued between ticks)
</verification>

<success_criteria>
- Dynamic add/remove works during active playback without audio glitches or errors
- New performers start near ensemble minimum pattern (blend in musically)
- Performer IDs are monotonically increasing (never reused)
- VoicePool resizes on add, minimum active floor of 2 maintained
- Canvas visualization and audio both reflect changes immediately
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualization-instruments-polish/03-03-SUMMARY.md`
</output>
