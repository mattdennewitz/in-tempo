---
phase: 05-velocity-humanization
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/score/velocity.ts
  - src/score/velocity.test.ts
autonomous: true

must_haves:
  truths:
    - "computeVelocity returns 1.0 when humanization is disabled"
    - "computeVelocity returns values in 0.3-1.0 range (floor prevents inaudible notes)"
    - "Different personality baseLoudness values produce different average velocities"
    - "noteIndexInPattern === 0 produces higher velocity than mid-pattern notes (accent)"
    - "Phrase contour produces a bell-curve shape across repetitions (not flat, not random)"
    - "Intensity scale multiplies variation range: subtle < moderate < expressive"
  artifacts:
    - path: "src/score/velocity.ts"
      provides: "Pure velocity computation functions"
      exports: ["computeVelocity", "VelocityContext", "VelocityConfig", "VelocityPersonality", "generateVelocityPersonality", "intensityScale"]
    - path: "src/score/velocity.test.ts"
      provides: "Test coverage for velocity model"
  key_links: []
---

<objective>
Build the velocity computation model as pure functions with full test coverage using TDD.

Purpose: The velocity model is the mathematical core of humanization — four stacked layers (jitter, personality, metric accent, phrase contour) produce musically meaningful per-note dynamics. Pure functions with defined I/O make this a textbook TDD candidate.

Output: `src/score/velocity.ts` with exported types and functions, fully tested.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-velocity-humanization/05-RESEARCH.md
</context>

<feature>
  <name>Velocity Computation Model</name>
  <files>src/score/velocity.ts, src/score/velocity.test.ts</files>
  <behavior>
    The velocity model computes a 0.0-1.0 normalized velocity for each note event from four layered factors:

    1. **Jitter** — Small per-note random variation around 1.0. Range: `1.0 ± (jitterAmount * intensityScale)`. jitterAmount is 0.02-0.12 per personality.
    2. **Personality** — Per-performer base loudness (0.7-1.0). Some performers are naturally louder/softer.
    3. **Metric accent** — First note of a pattern iteration (noteIndexInPattern === 0) gets a boost: `1.0 + 0.08 * intensityScale`. Non-accent notes get 1.0.
    4. **Phrase contour** — Bell curve across repetitions, peaking around 60% through. Creates crescendo-decrescendo across a performer's repetitions of a pattern. Max deviation: `0.15 * intensityScale`.

    Final velocity = clamp(personality * jitter * accent * contour, 0.3, 1.0)

    Floor at 0.3 (not 0.0) to prevent inaudible notes from multiplicative stacking.

    Intensity scales: subtle=0.4, moderate=0.7, expressive=1.0 (multiplier on all variation ranges).

    When `config.enabled === false`, return 1.0 (bypass — full uniform velocity).

    Types to export:
    ```
    VelocityPersonality { baseLoudness: number; jitterAmount: number }
    VelocityConfig { enabled: boolean; intensity: 'subtle' | 'moderate' | 'expressive' }
    VelocityContext { noteIndexInPattern, totalNotesInPattern, currentRep, totalReps, personality, config }
    ```

    Also export `generateVelocityPersonality()` that returns random `{ baseLoudness: 0.7-1.0, jitterAmount: 0.02-0.12 }`.

    Test cases (RED phase — write these first):
    - Disabled config → returns exactly 1.0
    - Enabled, default personality, no accent, single rep → returns value in [0.3, 1.0]
    - Floor enforcement: extreme low personality (0.7) + low contour + subtle → still >= 0.3
    - Ceiling enforcement: high personality (1.0) + accent + peak contour + expressive → still <= 1.0
    - Accent: noteIndexInPattern=0 produces higher average velocity than noteIndexInPattern=3 (run 100 samples, compare means)
    - Personality: baseLoudness=0.9 produces higher average than baseLoudness=0.7 (run 100 samples)
    - Contour: mid-repetition (rep 3 of 5) produces higher average than first rep (rep 1 of 5) (run 100 samples)
    - Intensity scaling: expressive produces wider velocity spread than subtle (run 100 samples, compare std dev)
    - generateVelocityPersonality: baseLoudness in [0.7, 1.0], jitterAmount in [0.02, 0.12]
  </behavior>
  <implementation>
    After tests pass:
    - `computeVelocity(ctx: VelocityContext): number` — main function
    - `intensityScale(intensity)` — returns 0.4 / 0.7 / 1.0
    - `phraseContour(currentRep, totalReps, scale)` — bell curve peaking at 60% progress
    - `generateVelocityPersonality()` — random personality generation

    Use `(Math.random() - 0.5) * 2 * range` for jitter (uniform, not Gaussian — indistinguishable at these small ranges per research).
  </implementation>
</feature>

<verification>
```bash
npx vitest run src/score/velocity.test.ts
```
All tests pass. No TypeScript errors in velocity.ts.
</verification>

<success_criteria>
- computeVelocity is a pure function (no side effects except Math.random for jitter)
- All test cases from the behavior section pass
- TypeScript compiles with no errors
- Exported types match what Plan 02 will consume
</success_criteria>

<output>
After completion, create `.planning/phases/05-velocity-humanization/05-01-SUMMARY.md`
</output>
