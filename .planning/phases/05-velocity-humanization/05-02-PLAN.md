---
phase: 05-velocity-humanization
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/score/ensemble.ts
  - src/audio/types.ts
  - src/audio/scheduler.ts
  - src/audio/sampler.ts
  - src/audio/engine.ts
  - public/synth-processor.js
autonomous: true

must_haves:
  truths:
    - "AgentNoteEvent always has a velocity field (never undefined)"
    - "Each performer's notes have distinct velocity characteristics (personality-driven)"
    - "Synth voices play at per-note gain levels (not hardcoded 0.3)"
    - "Sampled instruments receive 0-127 velocity (timbral variation from sample layers)"
    - "VelocityConfig persists across engine.reset() (user preference preserved)"
    - "Default performer count is 4 (not 8)"
  artifacts:
    - path: "src/score/ensemble.ts"
      provides: "AgentNoteEvent with velocity, AgentPersonality with velocity traits"
      contains: "velocity: computeVelocity"
    - path: "src/audio/types.ts"
      provides: "VelocityConfig type on EnsembleEngineState"
    - path: "src/audio/scheduler.ts"
      provides: "Velocity routing to synth gain and smplr velocity"
      contains: "event.velocity"
    - path: "src/audio/sampler.ts"
      provides: "SamplePlayer.play with velocity parameter"
      contains: "velocity"
    - path: "public/synth-processor.js"
      provides: "Per-note gain parameter in noteOn message"
      contains: "noteGain"
    - path: "src/audio/engine.ts"
      provides: "VelocityConfig storage, CFG-01 default 4 performers"
      contains: "initialPerformerCount = 4"
  key_links:
    - from: "src/score/ensemble.ts"
      to: "src/score/velocity.ts"
      via: "import computeVelocity, calls in PerformerAgent.tick()"
      pattern: "computeVelocity\\("
    - from: "src/audio/scheduler.ts"
      to: "src/score/ensemble.ts"
      via: "reads event.velocity from AgentNoteEvent"
      pattern: "event\\.velocity"
    - from: "src/audio/scheduler.ts"
      to: "public/synth-processor.js"
      via: "posts gain in noteOn message"
      pattern: "gain:"
    - from: "src/audio/scheduler.ts"
      to: "src/audio/sampler.ts"
      via: "passes velocity to SamplePlayer.play()"
      pattern: "samplePlayer\\.play.*velocity"
    - from: "src/audio/engine.ts"
      to: "src/score/ensemble.ts"
      via: "passes VelocityConfig to Ensemble constructor"
      pattern: "new Ensemble"
---

<objective>
Wire velocity through the entire audio pipeline: ensemble computes it, scheduler routes it, synth and sampler apply it. Also change default performer count to 4 (CFG-01).

Purpose: This is the integration plan — connecting the velocity model (Plan 01) to the existing audio engine so every note plays with humanized dynamics.

Output: All note events carry velocity; synth voices use per-note gain; sampled instruments receive 0-127 velocity for timbral variation; engine defaults to 4 performers.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-velocity-humanization/05-RESEARCH.md
@.planning/phases/05-velocity-humanization/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add velocity to AgentNoteEvent and wire through Ensemble</name>
  <files>src/score/ensemble.ts, src/audio/types.ts</files>
  <action>
    **src/audio/types.ts:**
    1. Add `velocity: number` to `AgentNoteEvent` interface (move it here if needed, or update wherever it's defined — currently in ensemble.ts).
       Actually: AgentNoteEvent is defined in ensemble.ts. Keep it there. Just add the field.
    2. Add `VelocityConfig` type to types.ts (imported from velocity.ts or defined here):
       ```typescript
       export type { VelocityConfig } from '../score/velocity.ts';
       ```
    3. Add to `EnsembleEngineState`:
       ```typescript
       humanizationEnabled: boolean;
       humanizationIntensity: 'subtle' | 'moderate' | 'expressive';
       ```

    **src/score/ensemble.ts:**
    1. Import `computeVelocity, generateVelocityPersonality, VelocityConfig, VelocityPersonality` from `./velocity.ts`.
    2. Extend `AgentPersonality` with velocity fields:
       ```typescript
       baseLoudness: number;   // 0.7-1.0
       jitterAmount: number;   // 0.02-0.12
       ```
    3. Update `generatePersonality()` to include velocity traits using `generateVelocityPersonality()`.
    4. Add `velocity: number` to `AgentNoteEvent` interface.
    5. Ensemble constructor: accept optional `VelocityConfig` parameter (defaults to `{ enabled: true, intensity: 'moderate' }`).
       Store as `private velocityConfig: VelocityConfig`.
    6. Add `setVelocityConfig(config: VelocityConfig)` method on Ensemble to allow live updates.
    7. In `PerformerAgent.tick()`, after confirming `note.midi !== 0`, compute velocity:
       ```typescript
       const velocityCtx: VelocityContext = {
         noteIndexInPattern: s.noteIndex - 1,  // already incremented
         totalNotesInPattern: pattern.notes.length,
         currentRep: s.totalRepetitions - s.repetitionsRemaining + 1,
         totalReps: s.totalRepetitions,
         personality: {
           baseLoudness: s.personality.baseLoudness,
           jitterAmount: s.personality.jitterAmount,
         },
         config: this.velocityConfig,
       };
       ```
       Return `{ performerId: s.id, midi: note.midi, duration: note.duration, velocity: computeVelocity(velocityCtx) }`.
    8. PerformerAgent needs access to velocityConfig. Pass it in constructor and store as private field.
       Ensemble passes its velocityConfig to each PerformerAgent.
       Add a method to update config on all agents when Ensemble.setVelocityConfig is called.
  </action>
  <verify>
    ```bash
    npx tsc --noEmit
    ```
    No type errors. AgentNoteEvent has velocity field everywhere it's used.
  </verify>
  <done>Every AgentNoteEvent returned from Ensemble.tick() has a velocity: number field between 0.3-1.0. Different performers produce different velocity distributions due to personality traits.</done>
</task>

<task type="auto">
  <name>Task 2: Route velocity through Scheduler, SamplePlayer, and synth processor</name>
  <files>src/audio/scheduler.ts, src/audio/sampler.ts, public/synth-processor.js, src/audio/engine.ts</files>
  <action>
    **src/audio/sampler.ts:**
    1. Add optional `velocity` parameter to `play()`:
       ```typescript
       play(instrument: 'piano' | 'marimba', midi: number, time: number, duration: number, velocity?: number): void
       ```
    2. Pass velocity through to smplr `target.start({ note: midi, time, duration, velocity: velocity ?? 100 })`.
       smplr accepts 0-127 for velocity.

    **public/synth-processor.js:**
    1. Add `this.noteGain = this.maxGain;` in constructor (default per-note gain = maxGain).
    2. In noteOn handler with `data.time != null` (scheduled): store `gain: data.gain ?? this.maxGain` in `pendingNoteOn`.
    3. In noteOn handler without time (immediate): set `this.noteGain = data.gain ?? this.maxGain`.
    4. When activating pendingNoteOn in `process()`: set `this.noteGain = this.pendingNoteOn.gain ?? this.maxGain`.
    5. In render loop, replace `this.maxGain` with `this.noteGain`:
       ```javascript
       channel0[i] = (osc1 + osc2) * 0.5 * this.envelope * this.noteGain;
       ```

    **src/audio/scheduler.ts:**
    1. In `scheduleBeat()`, for synth voices: pass velocity-scaled gain in noteOn message:
       ```typescript
       voice.node.port.postMessage({
         type: 'noteOn',
         frequency,
         time,
         gain: event.velocity * 0.3  // 0.3 is maxGain, velocity scales it
       });
       ```
    2. For sampled instruments: convert velocity to 0-127 and pass to SamplePlayer:
       ```typescript
       const smplrVelocity = Math.round(event.velocity * 127);
       this.samplePlayer.play(instrument, event.midi, time, noteDurationSeconds, smplrVelocity);
       ```

    **src/audio/engine.ts:**
    1. Change `initialPerformerCount = 4` (was 8). This is CFG-01.
    2. Add `private velocityConfig: VelocityConfig = { enabled: true, intensity: 'moderate' }`.
       Import VelocityConfig from types or velocity.ts.
    3. Pass velocityConfig to `new Ensemble(count, patterns, mode, velocityConfig)` in `initialize()` and `setScoreMode()`.
    4. Add public methods:
       ```typescript
       setHumanization(enabled: boolean): void {
         this.velocityConfig = { ...this.velocityConfig, enabled };
         this.ensemble?.setVelocityConfig(this.velocityConfig);
         this.scheduler?.fireStateChange();
       }

       setHumanizationIntensity(intensity: 'subtle' | 'moderate' | 'expressive'): void {
         this.velocityConfig = { ...this.velocityConfig, intensity };
         this.ensemble?.setVelocityConfig(this.velocityConfig);
         this.scheduler?.fireStateChange();
       }
       ```
    5. Update `getState()` fallback to include `humanizationEnabled` and `humanizationIntensity`.
    6. Update Scheduler `getState()` to include humanization fields from ensemble or engine config.

    **src/App.tsx:**
    1. Update `INITIAL_STATE` to have `performerCount: 4` (was 8).
    2. Add `humanizationEnabled: true` and `humanizationIntensity: 'moderate'` to INITIAL_STATE.
  </action>
  <verify>
    ```bash
    npx tsc --noEmit && npx vitest run
    ```
    No type errors. Existing tests still pass. App compiles and runs.
  </verify>
  <done>
    Synth voices use per-note gain scaled by velocity (not hardcoded 0.3). Sampled instruments receive 0-127 velocity for timbral variation via sample layers. Engine defaults to 4 performers. VelocityConfig persists across reset (stored on AudioEngine, passed to new Ensemble instances).
  </done>
</task>

</tasks>

<verification>
```bash
# TypeScript compiles
npx tsc --noEmit

# Existing tests pass
npx vitest run

# Velocity tests from Plan 01 still pass
npx vitest run src/score/velocity.test.ts
```
</verification>

<success_criteria>
- Every note event carries velocity (never undefined)
- Synth voices use per-note gain (not hardcoded maxGain)
- Sampled instruments receive velocity 0-127 (enabling timbral variation from sample layers)
- Default performer count is 4
- VelocityConfig survives engine.reset() and setScoreMode()
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-velocity-humanization/05-02-SUMMARY.md`
</output>
