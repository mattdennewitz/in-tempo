---
phase: 01-audio-engine-score-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/audio/voice-pool.ts
  - src/audio/scheduler.ts
  - src/audio/engine.ts
  - src/score/performer.ts
autonomous: true

must_haves:
  truths:
    - "AudioEngine can be initialized, started, stopped, and reset programmatically"
    - "Performer advances through patterns with random 2-8 repetitions and occasional rests"
    - "Voice pool manages a fixed set of AudioWorkletNodes without creating or destroying nodes during playback"
    - "Scheduler uses lookahead pattern with AudioContext.currentTime, never setTimeout for note timing"
  artifacts:
    - path: "src/audio/voice-pool.ts"
      provides: "Fixed pool of AudioWorkletNode voices"
      exports: ["VoicePool"]
      min_lines: 30
    - path: "src/audio/scheduler.ts"
      provides: "Lookahead scheduler using Two Clocks pattern"
      exports: ["Scheduler"]
      min_lines: 60
    - path: "src/audio/engine.ts"
      provides: "AudioEngine facade class"
      exports: ["AudioEngine"]
      min_lines: 50
    - path: "src/score/performer.ts"
      provides: "Single performer pattern navigation logic"
      exports: ["Performer"]
      min_lines: 50
  key_links:
    - from: "src/audio/engine.ts"
      to: "src/audio/scheduler.ts"
      via: "creates and controls Scheduler instance"
      pattern: "new Scheduler"
    - from: "src/audio/engine.ts"
      to: "src/audio/voice-pool.ts"
      via: "creates VoicePool and passes to Scheduler"
      pattern: "new VoicePool"
    - from: "src/audio/scheduler.ts"
      to: "src/score/performer.ts"
      via: "calls performer.nextNote() in scheduling loop"
      pattern: "performer.*nextNote"
    - from: "src/audio/scheduler.ts"
      to: "src/audio/voice-pool.ts"
      via: "claims and releases voices for each note"
      pattern: "voicePool\\.(claim|release)"
    - from: "src/audio/engine.ts"
      to: "public/synth-processor.js"
      via: "loads worklet module via addModule URL"
      pattern: "addModule.*synth-processor"
---

<objective>
Build the complete audio engine: voice pool, lookahead scheduler, engine facade, and performer logic. After this plan, the audio engine can be driven programmatically to play through Riley's score.

Purpose: This is the core technical challenge of the phase -- rock-solid audio timing with the Two Clocks lookahead pattern, AudioWorklet-based synthesis, and memory-safe voice management.
Output: Four TypeScript modules forming a complete, framework-agnostic audio engine.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-audio-engine-score-foundation/01-RESEARCH.md
@.planning/phases/01-audio-engine-score-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Voice pool and performer logic</name>
  <files>
    src/audio/voice-pool.ts
    src/score/performer.ts
  </files>
  <action>
    **VoicePool (src/audio/voice-pool.ts):**

    Create a VoicePool class that manages a fixed set of AudioWorkletNode instances:
    - Constructor takes AudioContext and size (default 4). Creates `size` AudioWorkletNode instances using the 'synth-processor' processor name, connects each to audioContext.destination.
    - `claim(): { node: AudioWorkletNode; index: number } | null` -- returns the next available voice, or null if all busy. Track availability with a Set of indices.
    - `release(index: number): void` -- marks voice as available again.
    - `stopAll(): void` -- sends `{ type: 'stop' }` message to all voices (immediate silence) and marks all as available.
    - `dispose(): void` -- disconnects all nodes (for cleanup on reset/destroy).

    Voice stealing: If all voices are busy when claim() is called, steal the oldest claimed voice (send it a 'stop' message, reclaim it). Track claim order to enable this.

    **Performer (src/score/performer.ts):**

    Create a Performer class that navigates through the score patterns:
    - Constructor takes the PATTERNS array (imported from score/patterns).
    - State: currentPatternIndex (0-based), currentNoteIndex (within pattern), repetitionsRemaining, shouldRest (boolean for inter-pattern rest).
    - `nextNote(): ScoreNote | null` -- returns the next note to play, or null if performance is complete (past pattern 53). Handles:
      - Returns the current note in the current pattern iteration
      - When a pattern iteration ends, decrements repetitionsRemaining
      - When repetitions exhausted, advances to next pattern, rolls new random repetitions (2-8 uniform)
      - ~30% chance of inserting a rest beat between patterns (return a ScoreNote with midi:0, duration:1)
      - Returns null when currentPatternIndex >= PATTERNS.length (performance complete)
    - `get currentPattern(): number` -- returns 1-based pattern number (1-53), clamped to 53 if complete
    - `get isComplete(): boolean` -- true when all patterns exhausted
    - `reset(): void` -- back to pattern 1, note 0, fresh repetition count

    Import types from `../audio/types` (ScoreNote, Pattern). Import PATTERNS from `./patterns`.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm both files compile. Manually verify: VoicePool exports the class, Performer exports the class. Performer.nextNote returns ScoreNote or null. Performer.reset sets state back to initial.
  </verify>
  <done>
    VoicePool manages fixed AudioWorkletNode pool with claim/release/steal. Performer navigates 53 patterns with random repetitions and occasional rests. Both compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Lookahead scheduler and AudioEngine facade</name>
  <files>
    src/audio/scheduler.ts
    src/audio/engine.ts
  </files>
  <action>
    **Scheduler (src/audio/scheduler.ts):**

    Implement the Chris Wilson "Two Clocks" lookahead scheduler:
    - Constructor takes AudioContext, VoicePool, and Performer.
    - Constants: `SCHEDULE_AHEAD_TIME = 0.1` (100ms), `TIMER_INTERVAL = 25` (ms).
    - State: nextNoteTime (AudioContext time of next note), bpm (default 120), playing (boolean), timerId.
    - `start(): void` -- sets nextNoteTime to audioContext.currentTime, sets playing=true, begins tick loop.
    - `stop(): void` -- sets playing=false, clears timerId. Does NOT call voicePool.stopAll() (let current note ring out per user decision). Schedules a noteOff for any currently-sounding voice after a short delay.
    - `reset(): void` -- calls stop(), then voicePool.stopAll() (hard silence), then performer.reset().
    - `setBpm(bpm: number): void` -- clamps to 100-180 range, stores new value. Takes effect on next note naturally (per user decision).
    - `getState(): EngineState` -- returns { playing, currentPattern: performer.currentPattern, bpm }.
    - `onStateChange: ((state: EngineState) => void) | null` -- callback for UI updates.

    The tick loop:
    ```
    tick():
      while nextNoteTime < audioContext.currentTime + SCHEDULE_AHEAD_TIME:
        scheduleNote(nextNoteTime)
        advanceTime()
      if playing:
        timerId = setTimeout(tick, TIMER_INTERVAL)
    ```

    scheduleNote(time):
      - Get next note from performer.nextNote()
      - If null (performance complete): call stop(), fire onStateChange with playing=false, return
      - If midi === 0 (rest): do nothing (time still advances)
      - Otherwise: claim a voice from pool, send noteOn with frequency (midiToFrequency), schedule a noteOff after note duration using setTimeout with delay calculated from (noteEndTime - audioContext.currentTime) * 1000. On noteOff, release the voice back to pool.
      - Fire onStateChange callback after each note (so UI can update pattern number)

    advanceTime():
      - Calculate note duration in seconds: `(currentNote.duration * 60) / (bpm * 2)` (duration is in eighth notes, so divide BPM-based beat by 2 since BPM = quarter notes per minute)
      - nextNoteTime += calculated duration

    **AudioEngine (src/audio/engine.ts):**

    Facade class exposing clean API for React:
    - Private state: audioContext, voicePool, scheduler, performer, initialized (boolean).
    - `async initialize(): Promise<void>` -- creates AudioContext, loads worklet module via `audioContext.audioWorklet.addModule('/synth-processor.js')`, creates VoicePool(audioContext, 4), creates Performer(PATTERNS), creates Scheduler(audioContext, voicePool, performer). Sets initialized=true.
    - `async start(): Promise<void>` -- if not initialized, call initialize(). Handle autoplay: if audioContext.state === 'suspended', await audioContext.resume(). Then scheduler.start().
    - `stop(): void` -- scheduler.stop().
    - `reset(): void` -- scheduler.reset().
    - `setBpm(bpm: number): void` -- scheduler.setBpm(bpm).
    - `getState(): EngineState` -- scheduler.getState() or default { playing: false, currentPattern: 1, bpm: 120 }.
    - `set onStateChange(cb: (state: EngineState) => void)` -- passes through to scheduler.onStateChange.
    - `dispose(): void` -- stop, voicePool.dispose(), audioContext.close().

    The engine is completely framework-agnostic. No React imports. No DOM access.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm compilation. Verify: AudioEngine exports the class. Scheduler implements the lookahead loop. Engine handles autoplay policy. BPM is clamped to 100-180. Run `npx vite build` to confirm the full project builds.
  </verify>
  <done>
    Scheduler implements Two Clocks lookahead pattern with 100ms window / 25ms interval. Engine facade provides clean start/stop/reset/setBpm API. Voice pool integration handles note scheduling and release. All audio timing uses AudioContext.currentTime, never setTimeout for musical timing (setTimeout only for the lookahead loop itself and noteOff scheduling).
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vite build` succeeds
- AudioEngine.start() handles autoplay (checks audioContext.state)
- Scheduler uses SCHEDULE_AHEAD_TIME = 0.1 and TIMER_INTERVAL = 25
- VoicePool creates exactly 4 nodes, has claim/release/stopAll
- Performer iterates patterns 1-53 with 2-8 random repetitions
- BPM is clamped to 100-180 range
- No React or DOM dependencies in any audio/ or score/ file
</verification>

<success_criteria>
Complete audio engine that can be initialized, started, stopped, and reset. Performer advances through all 53 patterns. Voice pool prevents memory leaks. Scheduler provides rock-solid timing via lookahead pattern. All modules are framework-agnostic.
</success_criteria>

<output>
After completion, create `.planning/phases/01-audio-engine-score-foundation/01-02-SUMMARY.md`
</output>
