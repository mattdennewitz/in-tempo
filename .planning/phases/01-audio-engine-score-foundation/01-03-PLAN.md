---
phase: 01-audio-engine-score-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/components/Transport.tsx
  - src/components/BpmSlider.tsx
  - src/components/PatternDisplay.tsx
  - src/App.tsx
  - src/App.css
  - src/index.css
autonomous: false

must_haves:
  truths:
    - "User clicks Start and hears notes playing with rock-solid timing via synth voice"
    - "User can Stop and the current note rings out then silence"
    - "User can Reset and performance returns to pattern 1"
    - "User can change BPM via slider and tempo shifts on next note"
    - "Pattern display shows current pattern number updating as performance plays"
    - "Performance auto-stops when pattern 53 completes"
  artifacts:
    - path: "src/components/Transport.tsx"
      provides: "Start/Stop/Reset button row"
      exports: ["Transport"]
      min_lines: 20
    - path: "src/components/BpmSlider.tsx"
      provides: "Horizontal BPM slider with value display"
      exports: ["BpmSlider"]
      min_lines: 15
    - path: "src/components/PatternDisplay.tsx"
      provides: "Current pattern number display"
      exports: ["PatternDisplay"]
      min_lines: 10
    - path: "src/App.tsx"
      provides: "Main app wiring audio engine to UI components"
      min_lines: 40
  key_links:
    - from: "src/App.tsx"
      to: "src/audio/engine.ts"
      via: "creates AudioEngine instance, calls start/stop/reset/setBpm"
      pattern: "new AudioEngine|engine\\.(start|stop|reset|setBpm)"
    - from: "src/App.tsx"
      to: "src/components/Transport.tsx"
      via: "passes onStart/onStop/onReset callbacks and playing state"
      pattern: "Transport.*onStart|onStop|onReset"
    - from: "src/App.tsx"
      to: "src/components/BpmSlider.tsx"
      via: "passes bpm value and onChange callback"
      pattern: "BpmSlider.*bpm|onChange"
    - from: "src/App.tsx"
      to: "src/components/PatternDisplay.tsx"
      via: "passes currentPattern number from engine state"
      pattern: "PatternDisplay.*pattern"
    - from: "src/App.tsx"
      to: "src/audio/engine.ts"
      via: "engine.onStateChange updates React state for UI reactivity"
      pattern: "onStateChange"
---

<objective>
Build the React UI components (Transport, BPM slider, Pattern display) and wire them to the AudioEngine in App.tsx, producing the complete working application.

Purpose: Delivers the user-facing experience -- the ability to hear Riley's In C played by a single performer with full transport control.
Output: Working application with Start/Stop/Reset, BPM slider, and pattern display.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-audio-engine-score-foundation/01-RESEARCH.md
@.planning/phases/01-audio-engine-score-foundation/01-01-SUMMARY.md
@.planning/phases/01-audio-engine-score-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: UI components and App integration</name>
  <files>
    src/components/Transport.tsx
    src/components/BpmSlider.tsx
    src/components/PatternDisplay.tsx
    src/App.tsx
    src/App.css
    src/index.css
  </files>
  <action>
    **Transport.tsx:**

    Props: `{ playing: boolean; onStart: () => void; onStop: () => void; onReset: () => void }`.

    Render a horizontal row of three buttons, centered:
    - "Start" button: calls onStart. Disabled when playing=true.
    - "Stop" button: calls onStop. Disabled when playing=false.
    - "Reset" button: calls onReset. Disabled when playing=true (must stop first).

    Style buttons with clean, minimal CSS -- no framework needed. Subtle border, slight border-radius, comfortable padding. Use a neutral color scheme (grays, one accent for Start). Buttons should look presentable but not over-designed (Phase 3 applies final palette).

    **BpmSlider.tsx:**

    Props: `{ bpm: number; onChange: (bpm: number) => void; disabled?: boolean }`.

    Render a horizontal slider (input type="range") with:
    - Range: min=100, max=180, step=1
    - Current value displayed to the right: "{bpm} BPM"
    - Label text "Tempo" to the left (optional, use discretion)
    - Centered below the transport buttons
    - Clean styling consistent with transport buttons

    **PatternDisplay.tsx:**

    Props: `{ currentPattern: number; totalPatterns: number; playing: boolean }`.

    Render centered text: "Pattern {currentPattern} of {totalPatterns}" per user decision (no progress bar).
    When not playing and currentPattern === 1, show "Ready" or "Pattern 1 of 53".
    When performance is complete (playing false, pattern at 53), show "Performance Complete".
    Clean typography, slightly larger text than controls.

    **App.tsx:**

    Wire everything together:
    - Create AudioEngine instance as a ref (useRef) -- persists across renders, framework-agnostic.
    - React state: playing (boolean), currentPattern (number), bpm (number, default 120).
    - On mount (useEffect), set up engine.onStateChange callback that updates React state (playing, currentPattern). Clean up on unmount with engine.dispose().
    - Start handler: async, calls engine.start(). This handles AudioContext creation and autoplay resume on first click.
    - Stop handler: calls engine.stop().
    - Reset handler: calls engine.reset(), sets bpm state back to 120.
    - BPM change handler: calls engine.setBpm(newBpm), updates bpm state.
    - Layout: vertically centered on page, stacked: PatternDisplay on top, Transport in the middle, BpmSlider below. No header or title per user decision. Use flexbox centering with min-height: 100vh.

    **App.css / index.css:**

    Minimal, clean styling:
    - Light background (#fafafa or similar off-white)
    - System sans-serif font stack
    - Centered content layout (flexbox, min-height: 100vh)
    - Button styles: clean borders, subtle hover states, comfortable sizing
    - Slider styling: reasonable width (~250-300px), styled thumb if easy
    - No animations, no shadows, no gradients -- clean and presentable per user decision
    - Responsive enough that it looks fine on a standard desktop browser (no mobile optimization needed)
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm all components compile. Run `npx vite build` to confirm the full app builds. Start the dev server with `npm run dev` and verify in the terminal that it starts without errors.
  </verify>
  <done>
    All three components render correctly. App.tsx wires AudioEngine to UI. Transport buttons show correct enabled/disabled states. BPM slider ranges 100-180. Pattern display updates during playback. Full app builds without errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify complete audio playback experience</name>
  <files>none (verification only)</files>
  <action>
    Ensure the dev server is running (`npm run dev`). Present the user with verification steps to confirm the complete Phase 1 experience works end-to-end. This is a human verification checkpoint -- no code changes are made.
  </action>
  <verify>
    User confirms all 10 verification steps pass (see how-to-verify below).
  </verify>
  <done>
    User has approved the audio playback experience: notes play with steady timing, transport controls work correctly, BPM slider adjusts tempo, pattern display updates, and memory is stable.
  </done>
  <what-built>
    Complete Phase 1 application: a single performer plays through Riley's 53 In C patterns via AudioWorklet synthesis, controlled by Start/Stop/Reset transport and BPM slider, with current pattern number displayed.
  </what-built>
  <how-to-verify>
    1. Open the dev server URL (likely http://localhost:5173) in Chrome
    2. You should see: pattern display, three transport buttons (Start enabled, Stop/Reset disabled), BPM slider at 120
    3. Click "Start" -- you should hear notes playing with a warm sine-like tone. Pattern number should start incrementing.
    4. Move the BPM slider -- tempo should change on the next note. Try 100 (slow) and 180 (fast).
    5. Click "Stop" -- the current note should ring out briefly, then silence. Stop becomes disabled, Start/Reset become enabled.
    6. Click "Start" again -- playback resumes from where it left off.
    7. Click "Stop", then "Reset" -- pattern display should show pattern 1 again.
    8. Click "Start" after reset -- playback begins from pattern 1.
    9. Listen for ~30 seconds: notes should sound musical (recognizable melodic fragments, not random beeps). Timing should be steady with no stuttering.
    10. Open DevTools > Memory tab, take a heap snapshot, let it play for 2-3 minutes, take another snapshot. Memory should be stable (no significant growth).
  </how-to-verify>
  <resume-signal>Type "approved" if audio plays correctly with working transport controls. Otherwise describe what's wrong (no sound, timing issues, UI problems, etc.)</resume-signal>
</task>

</tasks>

<verification>
- User clicks Start and hears notes with steady timing
- Stop lets current note decay, then silence
- Reset returns to pattern 1
- BPM slider changes tempo on next note (range 100-180)
- Pattern display shows current pattern updating during playback
- No TypeScript errors, clean build
- No console errors during normal operation
- Memory stable over several minutes of playback
</verification>

<success_criteria>
User can start, stop, reset, and adjust tempo of a single-performer In C performance. Audio timing is rock-solid. UI is clean and functional. Pattern number updates in real time. This satisfies all Phase 1 success criteria from the roadmap.
</success_criteria>

<output>
After completion, create `.planning/phases/01-audio-engine-score-foundation/01-03-SUMMARY.md`
</output>
