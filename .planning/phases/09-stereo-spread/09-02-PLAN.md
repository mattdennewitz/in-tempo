---
phase: 09-stereo-spread
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/audio/panner.ts
  - src/audio/sampler.ts
  - src/audio/voice-pool.ts
  - src/audio/scheduler.ts
  - src/audio/engine.ts
  - src/score/ensemble.ts
autonomous: true

must_haves:
  truths:
    - "Each performer's audio output is panned to a distinct stereo position"
    - "Pan positions are stable across resets and replays with the same seed"
    - "Performers are evenly distributed across the stereo field"
    - "Synth voices route through the correct performer's pan node on every note"
    - "Sampled instruments (piano/marimba) play from their performer's pan position"
  artifacts:
    - path: "src/audio/panner.ts"
      provides: "createPerformerPanNode helper + computePanPositions"
      exports: ["computePanPositions", "createPerformerPanNode"]
    - path: "src/audio/sampler.ts"
      provides: "Per-group sampled instrument instances (3 pan positions per instrument type)"
      contains: "CacheStorage"
    - path: "src/audio/scheduler.ts"
      provides: "Per-note pan routing for synth voices and sampled instruments"
      contains: "performerPanNodes"
    - path: "src/audio/engine.ts"
      provides: "Pan node creation during initialize() using computePanPositions"
      contains: "computePanPositions"
  key_links:
    - from: "src/audio/engine.ts"
      to: "src/audio/panner.ts"
      via: "computePanPositions called during initialize()"
      pattern: "computePanPositions"
    - from: "src/audio/scheduler.ts"
      to: "src/audio/panner.ts"
      via: "performerPanNodes map used in scheduleBeat()"
      pattern: "performerPanNodes"
    - from: "src/audio/sampler.ts"
      to: "StereoPannerNode"
      via: "Per-group instances route through pan nodes"
      pattern: "destination.*pan"
---

<objective>
Wire StereoPannerNodes into the audio graph so each performer's notes (synth and sampled) play from a distinct stereo position.

Purpose: Spatial clarity -- listeners on headphones hear each performer at a different point in the stereo field, making the ensemble sound more alive and easier to follow.
Output: Complete stereo spread feature integrated into the audio engine.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-stereo-spread/09-RESEARCH.md
@.planning/phases/09-stereo-spread/09-01-SUMMARY.md
@src/audio/panner.ts
@src/audio/engine.ts
@src/audio/scheduler.ts
@src/audio/sampler.ts
@src/audio/voice-pool.ts
@src/score/ensemble.ts
@src/score/rng.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create per-performer pan nodes and refactor SamplePlayer for per-group instances</name>
  <files>src/audio/panner.ts, src/audio/sampler.ts, src/audio/engine.ts, src/score/ensemble.ts</files>
  <action>
**1. Add createPerformerPanNode to panner.ts:**

Add a helper to `src/audio/panner.ts`:
```typescript
export function createPerformerPanNode(
  audioContext: AudioContext,
  panValue: number,
  destination: AudioNode,
): StereoPannerNode {
  const panner = audioContext.createStereoPanner();
  panner.pan.value = panValue;
  panner.connect(destination);
  return panner;
}
```

**2. Refactor SamplePlayer for per-group pan routing (Pattern 5 from research):**

Modify `src/audio/sampler.ts`:
- Import `CacheStorage` from smplr.
- Change `initialize()` to accept an optional `panGroups` parameter: `initialize(panGroups?: { left: StereoPannerNode; center: StereoPannerNode; right: StereoPannerNode })`.
- If panGroups provided, create 3 piano instances and 3 marimba instances, each routed to left/center/right pan nodes via their `destination` option. Use shared `CacheStorage` to avoid redundant CDN fetches.
- If panGroups not provided (backward compat), use existing single-instance behavior.
- Add method `playPanned(instrument, midi, time, duration, velocity, panValue)` that selects the nearest piano/marimba instance based on panValue: `<-0.33` = left, `>0.33` = right, else center.
- Keep the existing `play()` method working for backward compatibility.
- Update `dispose()` to clean up all instances.

**3. Compute pan positions in Engine.initialize() -- AFTER all ensemble RNG calls:**

In `src/audio/engine.ts`, in `initialize()`:
- Import `computePanPositions` and `createPerformerPanNode` from `./panner.ts`.
- AFTER `new Ensemble(...)` (which consumes RNG for personality + entry delays), call `computePanPositions(this.initialPerformerCount, rng)` to get pan values. This appends RNG calls at the end, preserving existing RNG sequence per Pitfall 6.
- Create a `Map<number, StereoPannerNode>` mapping performer ID to pan node. For each performer (id 0 to count-1), create a StereoPannerNode via `createPerformerPanNode(audioContext, panPositions[i], audioContext.destination)`.
- Store this map as `this.performerPanNodes`.
- Create 3 StereoPannerNodes at pan values -0.67, 0, 0.67 for the per-group sampled instrument routing. Pass these as panGroups to `samplePlayer.initialize()`.
- Also create a `Map<number, number>` mapping performer ID to pan value (needed by scheduler for sampled instrument routing). Store as `this.performerPanValues`.

**4. Compute pan positions in Ensemble constructor (for state exposure):**

In `src/score/ensemble.ts`:
- Do NOT compute pan positions here. Pan positions are an audio-layer concern, not a score-layer concern. The Engine computes and passes them down.

**5. Apply same pan setup in setScoreMode() and setPerformerCount():**

In both `setScoreMode()` and `setPerformerCount()` methods in engine.ts, after rebuilding Ensemble:
- Dispose old pan nodes (disconnect).
- Recompute pan positions with `computePanPositions(count, rng)` -- the rng here is already consumed by Ensemble, so positions will differ from initialize(), but that's fine since mode/count changes reset the performance.
- Recreate the performerPanNodes map.
- Recreate per-group sampled instrument pan nodes and pass to samplePlayer.initialize().

**Important:** Pan position RNG calls MUST happen AFTER `new Ensemble(...)` in ALL code paths (initialize, setScoreMode, setPerformerCount) to avoid changing the existing RNG sequence for personality/timing.
  </action>
  <verify>
- `npx tsc --noEmit` passes (no type errors)
- `npx vitest run` passes (existing tests still work)
  </verify>
  <done>Per-performer StereoPannerNodes created during engine init, SamplePlayer supports per-group pan routing with 3 instances per instrument type, pan positions computed deterministically after ensemble RNG calls</done>
</task>

<task type="auto">
  <name>Task 2: Route synth voices and sampled notes through pan nodes in Scheduler</name>
  <files>src/audio/scheduler.ts, src/audio/engine.ts, src/audio/voice-pool.ts</files>
  <action>
**1. Pass pan context to Scheduler:**

Modify `Scheduler` constructor or add public fields (following the `velocityConfigRef` pattern):
- Add `performerPanNodes: Map<number, StereoPannerNode> | null = null` public field.
- Add `performerPanValues: Map<number, number> | null = null` public field.

In `engine.ts`, after creating the Scheduler, assign:
```typescript
this.scheduler.performerPanNodes = this.performerPanNodes;
this.scheduler.performerPanValues = this.performerPanValues;
```

Do this in ALL Scheduler creation sites: `initialize()`, `setScoreMode()`, `setPerformerCount()`.

**2. Route synth voices through per-performer pan nodes in scheduleBeat():**

In `scheduler.ts`, `scheduleBeat()`, in the synth branch:
- After `voicePool.claim()`, if `this.performerPanNodes` has an entry for `event.performerId`:
  - Disconnect the voice node from its current destination: `voice.node.disconnect()`
  - Connect to the performer's pan node: `voice.node.connect(panNode)`
- This handles voice stealing correctly: each note routes through the correct performer's pan node regardless of which performer previously used that voice.

**3. Route sampled instruments through nearest pan group:**

In `scheduler.ts`, `scheduleBeat()`, in the sampled instrument branch:
- Look up the performer's pan value from `this.performerPanValues`.
- Call `this.samplePlayer.playPanned(instrument, event.midi, offsetTime, noteDurationSeconds, smplrVelocity, panValue)` instead of `this.samplePlayer.play(...)`.
- If performerPanValues is null (backward compat), fall back to existing `play()`.

**4. Handle addPerformer/removePerformer in engine.ts:**

When `addPerformer()` is called:
- After the ensemble adds the agent, compute a pan position for the new performer. Use the "fill largest gap" strategy from Pitfall 4: find the two adjacent existing pan positions with the largest gap, place the new performer at the midpoint.
- Create a new StereoPannerNode for the new performer and add to the map.
- Update the scheduler's performerPanNodes and performerPanValues.

When `removePerformer()` is called:
- After the ensemble queues removal, disconnect and delete the performer's pan node from the map.
- Update the scheduler references.

**5. Clean up pan nodes in dispose() and reset():**

In `engine.ts`:
- In `dispose()`: disconnect all pan nodes, clear the maps.
- In `reset()`: do NOT dispose pan nodes (they survive reset, same as voice pool). Pan positions are stable across reset per STE-02.

**6. VoicePool change -- do NOT modify VoicePool's masterGain routing:**

The VoicePool currently connects all voices to a shared masterGain which connects to `audioContext.destination`. With per-performer panning, synth voices will be dynamically disconnected from masterGain and reconnected to per-performer pan nodes during scheduleBeat(). The masterGain still serves as the default connection and handles gain scaling. No changes needed to VoicePool itself -- all routing changes happen in Scheduler.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npx vitest run` passes
- Manual test: Start a performance with 4+ performers and headphones. Each performer should be audible at a distinct stereo position. Reset and restart with same seed -- positions should be the same. Change performer count and restart -- positions should redistribute evenly.
  </verify>
  <done>Synth voices route through per-performer StereoPannerNodes in scheduleBeat(), sampled instruments route through nearest per-group instance, add/remove performer updates pan infrastructure dynamically, pan positions stable across reset</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors
2. `npx vitest run` -- all existing tests pass (no regressions)
3. Manual headphone test: Start performance with 4 performers. Each performer should be audibly positioned at a different point in the stereo field.
4. Determinism test: Start with same seed twice -- performers should be at same pan positions.
5. Reset test: After reset, same seed produces same pan positions (STE-02).
6. Add/remove test: Adding a performer places them at a gap-filling position. Removing a performer doesn't shift existing performers.
</verification>

<success_criteria>
- Each performer's audio is panned to a distinct stereo position (STE-01)
- Pan positions are deterministic: same seed = same positions (STE-02)
- Performers are evenly distributed across the stereo field (STE-03)
- Both synth and sampled instruments are panned correctly
- No audible clicks from voice steal routing changes
- Existing tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/09-stereo-spread/09-02-SUMMARY.md`
</output>
