---
phase: 08-microtiming
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/score/timing.ts
  - src/score/timing.test.ts
  - src/score/ensemble.ts
autonomous: true

must_haves:
  truths:
    - "computeTimingOffset returns 0 when humanization is disabled"
    - "Swing shifts only odd-indexed beats forward, leaving even beats unchanged"
    - "Rush/drag personality bias creates a consistent directional offset per performer"
    - "Random jitter produces different offsets per note but stays within bounds"
    - "Density looseness adds extra spread proportional to performer density"
    - "Total offset is clamped to [-50ms, +50ms] regardless of layer stacking"
    - "AgentNoteEvent includes a timingOffset field on every note event"
    - "AgentPersonality includes rushDragBias and timingJitter fields"
  artifacts:
    - path: "src/score/timing.ts"
      provides: "Pure timing offset computation with swing, personality, jitter, density layers"
      exports: ["computeTimingOffset", "computeSwingOffset", "TimingContext", "TimingPersonality", "RubatoState", "computeRubatoMultiplier", "advanceRubato", "generateTimingPersonality"]
    - path: "src/score/timing.test.ts"
      provides: "Unit tests for all timing computation functions"
    - path: "src/score/ensemble.ts"
      provides: "Extended AgentPersonality with timing fields, AgentNoteEvent with timingOffset"
  key_links:
    - from: "src/score/timing.ts"
      to: "src/score/velocity.ts"
      via: "imports intensityScale and VelocityConfig"
      pattern: "import.*intensityScale.*velocity"
    - from: "src/score/ensemble.ts"
      to: "src/score/timing.ts"
      via: "imports computeTimingOffset and generateTimingPersonality"
      pattern: "import.*computeTimingOffset.*timing"
---

<objective>
Create the pure timing offset computation module (`timing.ts`) and extend ensemble types to carry timing information through the event pipeline.

Purpose: Establish the computational foundation for microtiming -- swing, per-performer rush/drag personality, random jitter, and density-based looseness -- as pure functions mirroring the velocity.ts pattern. Also prepare rubato types and computation for Plan 02 integration.

Output: Tested `timing.ts` module, extended `AgentPersonality` and `AgentNoteEvent` types, timing offset computed per note in Ensemble.tick().
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-microtiming/08-RESEARCH.md
@src/score/velocity.ts
@src/score/ensemble.ts
@src/score/rng.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD timing.ts -- pure timing offset computation</name>
  <files>src/score/timing.ts, src/score/timing.test.ts</files>
  <action>
Create `src/score/timing.test.ts` with tests FIRST (RED phase), then implement `src/score/timing.ts` (GREEN phase).

**Types to define in timing.ts:**

```typescript
export interface TimingPersonality {
  rushDragBias: number;    // -1.0 to +1.0, typically generated in [-0.3, +0.3]
  timingJitter: number;    // 0.0-1.0 scale for per-note random variation
}

export interface TimingContext {
  beatIndex: number;               // global beat counter (for swing: odd = offbeat)
  noteIndexInPattern: number;      // position within pattern (unused for now, reserved)
  personality: TimingPersonality;   // per-performer rush/drag bias
  density: number;                  // ensemble density 0.0-1.0
  config: VelocityConfig;          // shared humanization toggle + intensity (reuse from velocity.ts)
  secondsPerEighth: number;        // needed to convert swing fraction to seconds
}

export interface RubatoState {
  phase: number;    // current phase in radians, advances each beat
  period: number;   // oscillation period in beats (16-32)
}
```

**Functions to implement:**

1. `computeSwingOffset(beatIndex: number, secondsPerEighth: number, scale: number): number`
   - Returns 0 for even beatIndex (downbeats unchanged)
   - For odd beatIndex: returns `0.15 * scale * secondsPerEighth` (fraction of eighth note shifted forward)
   - At 120 BPM (0.25s per eighth), expressive intensity: 0.15 * 1.0 * 0.25 = 37.5ms

2. `computeTimingOffset(ctx: TimingContext, rng: SeededRng): number`
   - If `!ctx.config.enabled`, return 0
   - Compute scale via `intensityScale(ctx.config.intensity)` (import from velocity.ts)
   - Layer 1: swing = `computeSwingOffset(ctx.beatIndex, ctx.secondsPerEighth, scale)`
   - Layer 2: personality = `ctx.personality.rushDragBias * 0.040 * scale` (40ms max at full bias + intensity)
   - Layer 3: jitter = `(rng.random() - 0.5) * 2 * ctx.personality.timingJitter * 0.040 * scale`
   - Layer 4: density looseness = `ctx.density * 0.005 * scale`
   - Total = swing + personality + jitter + densityLooseness
   - **Clamp to [-0.050, +0.050]** (50ms, half the lookahead window)
   - Return clamped value

3. `computeRubatoMultiplier(rubato: RubatoState, scale: number): number`
   - Returns `1.0 + Math.sin(rubato.phase) * 0.03 * scale` (+/- 3% tempo variation at max)

4. `advanceRubato(rubato: RubatoState): RubatoState`
   - Returns new RubatoState with phase advanced by `(2 * Math.PI) / rubato.period`
   - Wrap phase to stay within [0, 2*PI]
   - Return new object (pure function, no mutation)

5. `generateTimingPersonality(rng: SeededRng): TimingPersonality`
   - rushDragBias: `(rng.random() - 0.5) * 0.6` => [-0.3, +0.3)
   - timingJitter: `0.3 + rng.random() * 0.7` => [0.3, 1.0) -- everyone has some jitter

**Test cases (write FIRST):**

- `computeTimingOffset` returns exactly 0 when config.enabled = false
- `computeSwingOffset` returns 0 for even beats
- `computeSwingOffset` returns positive value for odd beats proportional to scale
- `computeTimingOffset` with rushDragBias > 0 produces positive offset (drag)
- `computeTimingOffset` with rushDragBias < 0 produces negative offset (rush) -- test with zero jitter to isolate
- Total offset never exceeds 50ms (test with max stacking: odd beat + max personality + max jitter + max density)
- Total offset never goes below -50ms
- `computeRubatoMultiplier` returns ~1.0 when phase=0
- `computeRubatoMultiplier` returns > 1.0 when phase=PI/2 (peak of sine)
- `advanceRubato` advances phase correctly and wraps at 2*PI
- `generateTimingPersonality` produces rushDragBias in [-0.3, 0.3) and timingJitter in [0.3, 1.0)

Use Vitest. Import SeededRng from rng.ts for deterministic tests.
  </action>
  <verify>
Run `npx vitest run src/score/timing.test.ts` -- all tests pass. Verify test count >= 10.
  </verify>
  <done>
timing.ts exports all 5 functions + 3 interfaces. All tests pass. Swing only affects odd beats. Offsets clamped to +/-50ms. Rubato multiplier oscillates around 1.0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend ensemble types and compute timing offset per note</name>
  <files>src/score/ensemble.ts</files>
  <action>
Modify `src/score/ensemble.ts` to:

1. **Extend AgentPersonality** -- add two new fields:
   ```typescript
   rushDragBias: number;      // -0.3 to +0.3
   timingJitter: number;      // 0.3 to 1.0
   ```

2. **Extend AgentNoteEvent** -- add timing offset:
   ```typescript
   export interface AgentNoteEvent {
     performerId: number;
     midi: number;
     duration: number;
     velocity: number;
     timingOffset: number;  // NEW: seconds, positive=late/drag, negative=early/rush
   }
   ```

3. **Update generatePersonality()** to include timing fields:
   - Import `generateTimingPersonality` from `./timing.ts`
   - Call `generateTimingPersonality(_rng)` and spread into the personality object
   - This adds rushDragBias and timingJitter alongside existing baseLoudness/jitterAmount

4. **Update PerformerAgent.tick()** to compute and return timingOffset:
   - Import `computeTimingOffset` and `TimingContext` from `./timing.ts`
   - After computing velocity (around line 337-354), create a TimingContext:
     ```typescript
     const timingCtx: TimingContext = {
       beatIndex: ???,  // Need beat index -- see below
       noteIndexInPattern: s.noteIndex - 1,
       personality: {
         rushDragBias: s.personality.rushDragBias,
         timingJitter: s.personality.timingJitter,
       },
       density: snapshot.density,
       config: this.velocityConfig,
       secondsPerEighth: 0, // Placeholder -- Scheduler will provide via Ensemble
     };
     ```
   - **Beat index problem:** PerformerAgent doesn't know the global beat index. Two options:
     - (a) Pass it through tick() -- changes the Ensemble interface
     - (b) Store a per-agent tick counter
   - **Use option (b):** Add a `tickCount` field to AgentState, increment on every tick() call (before the entry delay check). This gives each agent a consistent beat counter for swing calculation. Since agents tick in order and all see the same snapshot, the beat index is effectively the global beat counter from their perspective.
   - **secondsPerEighth problem:** PerformerAgent doesn't know BPM. Two options:
     - (a) Pass BPM through to the agent
     - (b) Have Ensemble accept BPM on tick()
   - **Use option (b):** Change `Ensemble.tick()` signature to `tick(bpm?: number): AgentNoteEvent[]`. Default to 120 if not provided (backward compatible). Pass to PerformerAgent.tick() as well: `tick(snapshot, bpm)`. Compute `secondsPerEighth = 60 / (bpm * 2)` inside the agent.
   - Compute timingOffset and include in the returned AgentNoteEvent:
     ```typescript
     return {
       performerId: s.id,
       midi: note.midi,
       duration: note.duration,
       velocity: computeVelocity(velocityCtx, this.rng),
       timingOffset: computeTimingOffset(timingCtx, this.rng),
     };
     ```

5. **Important:** The `timingOffset` computation calls `rng.random()` which changes the PRNG sequence. This is expected (see Research pitfall #5). Same seed + Phase 8 code = same performance. Seeds from before Phase 8 will produce different performances.

6. **Update Scheduler call site:** In `scheduler.ts`, update `this.ensemble.tick()` to `this.ensemble.tick(this._bpm)` so BPM is passed through. This is a one-line change but affects the contract.
  </action>
  <verify>
Run `npx vitest run` -- all existing tests still pass. Run `npx tsc --noEmit` -- no type errors. Verify AgentNoteEvent has timingOffset field. Verify generatePersonality returns rushDragBias and timingJitter.
  </verify>
  <done>
AgentPersonality has rushDragBias and timingJitter. AgentNoteEvent has timingOffset. Every note event from Ensemble.tick() includes a computed timing offset. Ensemble.tick() accepts optional BPM parameter. Scheduler passes BPM to ensemble.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run src/score/timing.test.ts` -- all timing tests pass (>= 10 tests)
2. `npx vitest run` -- all existing tests still pass (no regressions)
3. `npx tsc --noEmit` -- no type errors
4. Verify timing.ts exports match: computeTimingOffset, computeSwingOffset, computeRubatoMultiplier, advanceRubato, generateTimingPersonality, TimingContext, TimingPersonality, RubatoState
</verification>

<success_criteria>
- timing.ts has 5 pure functions mirroring velocity.ts architecture
- All timing offsets clamped to [-50ms, +50ms]
- Swing only affects odd beats (offbeats)
- AgentNoteEvent.timingOffset is populated on every note event
- AgentPersonality includes timing fields generated deterministically from SeededRng
- Rubato types defined and computation tested (wired in Plan 02)
- All tests pass, no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-microtiming/08-01-SUMMARY.md`
</output>
