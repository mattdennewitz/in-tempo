---
phase: 08-microtiming
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/audio/scheduler.ts
  - src/score/ensemble.ts
autonomous: true

must_haves:
  truths:
    - "Enabling swing shifts alternate eighth notes forward, audibly changing the groove feel"
    - "Each performer has a subtle but audible timing personality creating ensemble spread"
    - "Rubato gently breathes the effective tempo so the ensemble feels less mechanical"
    - "Microtiming is controlled through the existing humanization toggle and intensity levels"
    - "Timing offsets never cause notes to be dropped or scheduled in the past"
  artifacts:
    - path: "src/audio/scheduler.ts"
      provides: "Applies per-note timing offsets when scheduling audio, rubato modulates advanceTime"
      contains: "event.timingOffset"
    - path: "src/score/ensemble.ts"
      provides: "Ensemble owns RubatoState, advances rubato per tick, exposes tempo multiplier"
      contains: "RubatoState"
  key_links:
    - from: "src/audio/scheduler.ts"
      to: "src/score/ensemble.ts"
      via: "reads timingOffset from AgentNoteEvent, reads rubatoMultiplier from Ensemble"
      pattern: "event\\.timingOffset"
    - from: "src/score/ensemble.ts"
      to: "src/score/timing.ts"
      via: "imports computeRubatoMultiplier and advanceRubato"
      pattern: "import.*computeRubatoMultiplier.*timing"
---

<objective>
Wire timing offsets and rubato into the audio scheduling pipeline so microtiming is audible during playback.

Purpose: Complete the microtiming feature by applying per-note timing offsets in the Scheduler (swing, personality, jitter, density) and adding rubato tempo modulation to the Ensemble. All controlled by the existing humanization toggle/intensity.

Output: Fully functional microtiming -- audible swing on offbeats, per-performer rush/drag spread, gentle rubato breathing, all deterministic via seeded PRNG.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-microtiming/08-RESEARCH.md
@.planning/phases/08-microtiming/08-01-SUMMARY.md
@src/audio/scheduler.ts
@src/audio/engine.ts
@src/score/ensemble.ts
@src/score/timing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rubato to Ensemble and expose tempo multiplier</name>
  <files>src/score/ensemble.ts</files>
  <action>
Modify `src/score/ensemble.ts` to own and advance rubato state:

1. **Import rubato functions:**
   ```typescript
   import { computeRubatoMultiplier, advanceRubato, type RubatoState } from './timing.ts';
   ```

2. **Add RubatoState to Ensemble class:**
   - Private field: `private rubatoState: RubatoState;`
   - Initialize in constructor: `this.rubatoState = { phase: 0, period: rng.int(16, 32) };`
   - The period is seeded per-performance (16-32 beats) for variety.

3. **Expose a `rubatoMultiplier` getter or return value from tick():**
   - Option A: Add a `get rubatoMultiplier()` getter on Ensemble that Scheduler reads after tick().
   - Option B: Change tick() return to include the multiplier.
   - **Use Option A** (simpler, no return type change): Add a private `_lastRubatoMultiplier: number = 1.0` field. In tick(), after processing all agents, compute and store the rubato multiplier, then advance rubato state.

   ```typescript
   // At end of tick(), before return:
   this._lastRubatoMultiplier = computeRubatoMultiplier(
     this.rubatoState,
     intensityScale(this.velocityConfig.intensity) * (this.velocityConfig.enabled ? 1.0 : 0.0)
   );
   this.rubatoState = advanceRubato(this.rubatoState);
   ```

   Add getter:
   ```typescript
   get rubatoMultiplier(): number {
     return this._lastRubatoMultiplier;
   }
   ```

4. **Reset rubato on Ensemble.reset():**
   - Add `this.rubatoState = { phase: 0, period: this.rubatoState.period };` to reset() method.
   - Keep the period (it's a personality of the performance), just reset phase to 0.

5. **Import intensityScale from velocity.ts** (if not already imported) to scale rubato depth.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run` -- all tests pass.
  </verify>
  <done>
Ensemble owns RubatoState, computes and exposes rubatoMultiplier per tick, advances rubato phase each tick, resets rubato on reset().
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply timing offsets and rubato in Scheduler</name>
  <files>src/audio/scheduler.ts</files>
  <action>
Modify `src/audio/scheduler.ts` to apply per-note timing offsets and rubato:

1. **Apply timing offsets in scheduleBeat():**
   In the `for (const event of events)` loop, after the `if (event.midi === 0) continue;` check, compute the offset time:

   ```typescript
   // Apply per-note timing offset, clamped to prevent scheduling in the past
   const offsetTime = Math.max(
     this.audioContext.currentTime,
     time + event.timingOffset
   );
   ```

   Then use `offsetTime` instead of `time` for ALL scheduling calls:
   - Synth voice noteOn: `voice.node.port.postMessage({ type: 'noteOn', frequency, time: offsetTime, gain: event.velocity * 0.3 });`
   - Release timer: `const noteEndTime = offsetTime + noteDurationSeconds;` (release relative to offset start)
   - SamplePlayer: `this.samplePlayer.play(instrument, event.midi, offsetTime, noteDurationSeconds, smplrVelocity);`

   **Do NOT change** the MIDI recorder call -- it still records at quantized beatCounter (correct per Research pitfall #4).

2. **Apply rubato in advanceTime():**
   Read the ensemble's rubato multiplier and use it to modulate the grid:

   ```typescript
   private advanceTime(): void {
     const secondsPerEighth = 60 / (this._bpm * 2);
     const rubatoMultiplier = this.ensemble.rubatoMultiplier;
     this.nextNoteTime += secondsPerEighth * rubatoMultiplier;
   }
   ```

   This modulates the time between beats without changing `_bpm` (avoids UI feedback per Research anti-pattern). The rubato multiplier is already computed in Ensemble.tick() which runs in scheduleBeat() before advanceTime() is called.

3. **Verify the timing pipeline flow:**
   - `tick()` calls `scheduleBeat(time)` then `advanceTime()`
   - `scheduleBeat` calls `this.ensemble.tick(this._bpm)` which computes per-note timingOffset and updates rubatoMultiplier
   - Each note is scheduled at `time + event.timingOffset` (clamped)
   - `advanceTime` reads `this.ensemble.rubatoMultiplier` to modulate the next beat's grid position
   - This ordering is correct: ensemble tick happens first, rubato updates, then advanceTime reads the updated multiplier.

4. **Edge case: ensemble completion check.**
   The ensemble completion check in scheduleBeat happens after `this.ensemble.tick()`. The timingOffset on the last events of a completing ensemble will still be applied correctly since we process the events before checking isComplete.

5. **No changes to engine.ts needed.** The humanization toggle/intensity already flows through VelocityConfig which timing.ts reads. When humanization is disabled, computeTimingOffset returns 0, and rubatoMultiplier returns 1.0. The existing `setHumanization()` and `setHumanizationIntensity()` methods on AudioEngine propagate to Ensemble which timing functions consume.
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- no type errors
2. Run `npx vitest run` -- all tests pass
3. Manual verification: Open the app, start a performance with humanization enabled at "expressive" intensity. Listen for:
   - Timing spread between performers (some slightly ahead, some behind)
   - Swing feel on offbeats (subtle forward push on "and" beats)
   - Gentle tempo breathing (rubato)
4. Toggle humanization off -- timing should become perfectly grid-locked again
5. Verify same seed produces same performance (determinism preserved)
  </verify>
  <done>
Scheduler applies event.timingOffset to all note scheduling (synth + sampled). Rubato modulates advanceTime() via ensemble.rubatoMultiplier. Humanization toggle controls all microtiming. Notes never scheduled in the past (clamped to currentTime). MIDI recording unaffected (quantized beat index).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors across entire project
2. `npx vitest run` -- all tests pass (timing tests from 08-01 + any existing tests)
3. Start performance with humanization ON at expressive -- audible timing variety
4. Start performance with humanization OFF -- perfectly grid-locked, no offsets
5. Same seed + same settings = same performance (determinism check)
6. No dropped notes at any BPM (100-180 range)
7. MIDI export still produces valid files with quantized beat positions
</verification>

<success_criteria>
- Swing shifts alternate eighth notes forward (audible groove change at expressive intensity)
- Each performer has distinct rush/drag personality (audible temporal spread)
- Rubato gently modulates effective tempo (breathing feel, not jarring)
- All microtiming controlled by existing humanization toggle + intensity
- No notes dropped, no scheduling-in-the-past errors
- Deterministic via seeded PRNG (same seed = same timing offsets)
- MIDI recording unaffected by timing offsets
</success_criteria>

<output>
After completion, create `.planning/phases/08-microtiming/08-02-SUMMARY.md`
</output>
