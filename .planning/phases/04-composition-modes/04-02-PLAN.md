---
phase: 04-composition-modes
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/score/bjorklund.ts
  - src/score/euclidean.ts
  - src/score/score-modes.ts
  - src/audio/engine.ts
autonomous: true

must_haves:
  truths:
    - "Euclidean mode produces 20-40 fresh rhythmic patterns using Bjorklund's algorithm"
    - "AudioEngine.setScoreMode() stops playback, generates new patterns, rebuilds Ensemble"
    - "Mode switch does NOT auto-restart -- user must click Start"
    - "Riley mode remains the default and works unchanged"
  artifacts:
    - path: "src/score/bjorklund.ts"
      provides: "bjorklund(k, n) and rotatePattern utilities"
      exports: ["bjorklund", "rotatePattern"]
    - path: "src/score/euclidean.ts"
      provides: "generateEuclideanPatterns() returning Pattern[]"
      exports: ["generateEuclideanPatterns"]
    - path: "src/audio/engine.ts"
      provides: "setScoreMode(), currentMode, patternCount getters"
      contains: "setScoreMode"
  key_links:
    - from: "src/score/euclidean.ts"
      to: "src/score/bjorklund.ts"
      via: "import bjorklund and rotatePattern"
      pattern: "bjorklund\\("
    - from: "src/score/score-modes.ts"
      to: "src/score/euclidean.ts"
      via: "import generateEuclideanPatterns for euclidean case"
      pattern: "generateEuclideanPatterns"
    - from: "src/audio/engine.ts"
      to: "src/score/score-modes.ts"
      via: "import getPatternsForMode for setScoreMode"
      pattern: "getPatternsForMode"
    - from: "src/audio/engine.ts"
      to: "src/score/ensemble.ts"
      via: "new Ensemble with mode-selected patterns"
      pattern: "new Ensemble"
---

<objective>
Create Euclidean pattern generator using Bjorklund's algorithm and wire mode switching through AudioEngine.

Purpose: Completes the pattern generation side (all three modes produce Pattern[]) and adds the engine-level mode switching API that the UI will call.
Output: Bjorklund algorithm, Euclidean pattern factory, AudioEngine mode switching, score-modes wired to all three generators.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-composition-modes/04-CONTEXT.md
@.planning/phases/04-composition-modes/04-RESEARCH.md
@.planning/phases/04-composition-modes/04-01-SUMMARY.md
@src/audio/engine.ts
@src/score/score-modes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bjorklund Algorithm + Euclidean Pattern Factory</name>
  <files>src/score/bjorklund.ts, src/score/euclidean.ts</files>
  <action>
**Create `src/score/bjorklund.ts`:**

Implement Bjorklund's algorithm as documented in the RESEARCH.md code example:
- `bjorklund(k: number, n: number): number[]` -- distribute k pulses across n steps, returns binary array
- `rotatePattern(pattern: number[], offset: number): number[]` -- circular rotation
- Edge cases: k >= n returns all 1s, k === 0 returns all 0s

**Create `src/score/euclidean.ts`:**

Implement `generateEuclideanPatterns(): Pattern[]` following CONTEXT.md spec:

1. **Pattern count:** Random 20-40

2. **Progressive arc:** Track progress (0.0-1.0):
   - Early patterns: sparser (fewer pulses relative to steps)
   - Later patterns: denser (more pulses relative to steps)
   - Last ~5 patterns: simplify (fewer pulses per step count)

3. **Step counts:** 4-16 steps per pattern

4. **Pulse density:** Scale with progress:
   - `baseDensity = 0.2 + progress * 0.5` (20% to 70%)
   - `pulses = Math.max(1, Math.round(steps * baseDensity))`
   - Endgame override: last 5 patterns cap density at 0.3

5. **Rotation:** Apply random rotation offset `Math.floor(Math.random() * steps)` to create phase relationships

6. **Pitch assignment -- two types (per CONTEXT.md "mix of both"):**
   - ~40% single-pitch rhythmic pulses: pick one C-major pentatonic pitch (C D E G A, MIDI values from C3-C6), repeat for all pulses
   - ~60% melodic: assign different C-major pentatonic pitches to each pulse position. Use pentatonic scale (C D E G A -- no F or B) per RESEARCH.md recommendation to distinguish from generative mode's full diatonic palette.

7. **Rhythm-to-notes conversion:** For each step in the Euclidean pattern:
   - Pulse (1): create `ScoreNote` with assigned pitch and duration 1 (eighth note)
   - Rest (0): create `ScoreNote` with `midi: 0, duration: 1`

8. **Interlocking pairs:** ~30% chance to create a complementary partner pattern (invert the binary rhythm). When a pair is created, increment `i` to skip the next iteration. Adjust final count to stay within 20-40 range.

9. **Pitch range:** C3-C6 (MIDI 48-84), C major pentatonic only: filter to `midi % 12` in `[0, 2, 4, 7, 9]`

Import `ScoreNote` and `Pattern` from `../audio/types.ts`, and `bjorklund` and `rotatePattern` from `./bjorklund.ts`.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors.
Verify bjorklund(3, 8) produces a valid 8-element binary array with exactly 3 ones.
Verify generateEuclideanPatterns() returns 20-40 patterns with sequential IDs, all MIDI values are 0 or pentatonic C-major in 48-84.
  </verify>
  <done>
Bjorklund algorithm correctly distributes pulses. Euclidean factory produces 20-40 fresh pitched/rhythmic patterns with progressive density arc and interlocking pairs.
  </done>
</task>

<task type="auto">
  <name>Task 2: AudioEngine Mode Switching + Score Modes Wiring</name>
  <files>src/score/score-modes.ts, src/audio/engine.ts</files>
  <action>
**Update `src/score/score-modes.ts`:**
- Replace the euclidean placeholder with: `import { generateEuclideanPatterns } from './euclidean.ts';`
- Update the switch case: `case 'euclidean': return generateEuclideanPatterns();`

**Update `src/audio/engine.ts`:**

1. Add imports:
   - `import type { ScoreMode } from './types.ts';`
   - `import { getPatternsForMode } from '../score/score-modes.ts';`

2. Add private fields:
   - `private currentMode: ScoreMode = 'riley';`
   - `private currentPatterns: Pattern[] = PATTERNS;`

3. Add `setScoreMode(mode: ScoreMode): void` method:
   ```
   - Set this.currentMode = mode
   - Generate patterns: this.currentPatterns = getPatternsForMode(mode)
   - If initialized:
     - Stop scheduler: this.scheduler?.reset()
     - Stop all voices: this.voicePool?.stopAll()
     - Rebuild ensemble: this.ensemble = new Ensemble(this.performerCount, this.currentPatterns)
     - Rebuild scheduler: this.scheduler = new Scheduler(this.audioContext!, this.voicePool!, this.ensemble)
     - Reconnect onStateChange callback (store it before rebuilding, reattach after)
     - Fire state change to update UI
   - Do NOT auto-restart playback -- user must click Start
   ```

4. Add `get scoreMode(): ScoreMode` getter returning `this.currentMode`

5. Add `get patternCount(): number` getter returning `this.currentPatterns.length`

6. Update `initialize()`: use `this.currentPatterns` instead of `PATTERNS` when creating Ensemble:
   - `this.ensemble = new Ensemble(this.performerCount, this.currentPatterns);`

7. Update `getState()` to include `scoreMode` and `totalPatterns`:
   - Add `scoreMode: this.currentMode` to the returned state object
   - Add `totalPatterns: this.currentPatterns.length` to the returned state object
   - Update the fallback state to include `scoreMode: 'riley'` and `totalPatterns: 53`

8. Update `reset()`: should reset within current mode (not switch back to riley). Rebuild ensemble with `this.currentPatterns`.
   - Actually, the existing reset() calls scheduler.reset() which calls ensemble.reset(). This is fine -- it resets performers to pattern 0 within the current pattern set.

9. Remove the direct `import { PATTERNS } from '../score/patterns.ts';` if no longer needed (it may still be needed for the initial default value of currentPatterns). Keep it for now since `currentPatterns` initializes to `PATTERNS`.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors.
Verify that calling `engine.setScoreMode('generative')` then `engine.patternCount` returns a value between 30-80.
Verify that calling `engine.setScoreMode('riley')` then `engine.patternCount` returns 53.
  </verify>
  <done>
AudioEngine supports `setScoreMode()` which generates new patterns, rebuilds Ensemble and Scheduler, and fires state change. Mode switching works for all three modes. No auto-restart on mode switch.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run` passes (existing tests still work)
- `bjorklund(3, 8)` returns array of length 8 with 3 pulses
- `generateEuclideanPatterns()` returns 20-40 patterns with valid structure
- `engine.setScoreMode('euclidean')` + `engine.patternCount` returns 20-40
- `engine.setScoreMode('riley')` + `engine.patternCount` returns 53
</verification>

<success_criteria>
- All three score modes produce valid Pattern[] arrays
- AudioEngine mode switching stops playback, rebuilds ensemble, fires state change
- No auto-restart after mode switch
- Bjorklund algorithm correctly distributes pulses (verified with known test cases)
- Euclidean patterns use pentatonic scale to distinguish from generative mode
</success_criteria>

<output>
After completion, create `.planning/phases/04-composition-modes/04-02-SUMMARY.md`
</output>
