---
phase: 04-composition-modes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/audio/types.ts
  - src/score/ensemble.ts
  - src/score/generative.ts
  - src/score/score-modes.ts
autonomous: true

must_haves:
  truths:
    - "Ensemble works with any length Pattern[] (not just 53)"
    - "Generative mode produces 30-80 fresh C-major patterns each call with progressive arc"
    - "PerformerState exposes currentRep and totalReps for UI consumption"
    - "Band width scales proportionally with pattern count"
  artifacts:
    - path: "src/audio/types.ts"
      provides: "ScoreMode type, extended PerformerState with currentRep/totalReps, totalPatterns in EnsembleEngineState"
      contains: "ScoreMode"
    - path: "src/score/ensemble.ts"
      provides: "Dynamic finalPatternIndex, dynamic bandWidth, totalRepetitions in AgentState, rep tracking in performerStates"
      contains: "finalPatternIndex"
    - path: "src/score/generative.ts"
      provides: "generateGenerativePatterns() returning Pattern[]"
      exports: ["generateGenerativePatterns"]
    - path: "src/score/score-modes.ts"
      provides: "getPatternsForMode() factory function"
      exports: ["getPatternsForMode"]
  key_links:
    - from: "src/score/ensemble.ts"
      to: "patterns.length"
      via: "constructor derives finalPatternIndex from patterns.length - 1"
      pattern: "this\\.patterns\\.length\\s*-\\s*1"
    - from: "src/score/score-modes.ts"
      to: "src/score/generative.ts"
      via: "import and call generateGenerativePatterns"
      pattern: "generateGenerativePatterns"
---

<objective>
Make the Ensemble dynamic (variable pattern counts, proportional band width, repetition tracking) and create the generative pattern factory.

Purpose: Foundation for all composition modes -- the ensemble must handle any-length Pattern[] before mode switching can work. The generative factory is the most complex generator and benefits from a dedicated plan.
Output: Dynamic ensemble, ScoreMode type, generative pattern generator, score-mode factory function.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-composition-modes/04-CONTEXT.md
@.planning/phases/04-composition-modes/04-RESEARCH.md
@src/audio/types.ts
@src/score/ensemble.ts
@src/score/patterns.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dynamic Ensemble + Type Extensions</name>
  <files>src/audio/types.ts, src/score/ensemble.ts</files>
  <action>
**In `src/audio/types.ts`:**
- Add `export type ScoreMode = 'riley' | 'generative' | 'euclidean';`
- Add `currentRep: number;` and `totalReps: number;` to `PerformerState` interface
- Add `totalPatterns: number;` and `scoreMode: ScoreMode;` to `EnsembleEngineState` interface

**In `src/score/ensemble.ts`:**
1. Remove the two module-level constants:
   - `const BAND_WIDTH = 3;` -- replace with a private instance field on `Ensemble`
   - `const FINAL_PATTERN_INDEX = 52;` -- replace with a private instance field on `Ensemble`

2. In `Ensemble` constructor:
   - Derive `this.finalPatternIndex = patterns.length - 1;`
   - Derive `this.bandWidth = Math.max(2, Math.min(5, Math.round(patterns.length * 0.06)));`
   - Pass both values to each `PerformerAgent` constructor (add parameters)

3. In `PerformerAgent`:
   - Add `private finalPatternIndex: number` and `private bandWidth: number` constructor parameters
   - Replace all 5 references to `FINAL_PATTERN_INDEX` with `this.finalPatternIndex` (in `decisionLogic`, `handleEndgame` x2, `doRejoin`, and the endgame fraction calc)
   - Replace `BAND_WIDTH` usage in `enforceBand` -- since `enforceBand` is a module-level function, refactor it to accept `bandWidth` as a parameter. Update all call sites.

4. Add `totalRepetitions` field to `AgentState` interface (alongside existing `repetitionsRemaining`)
   - In `randomReps()`, store the result in a local, set both `totalRepetitions` and `repetitionsRemaining` to it
   - Update all places that call `this.randomReps()` to use the new dual-set pattern

5. In `Ensemble.performerStates` getter:
   - Add `currentRep` and `totalReps` to each returned object
   - `totalReps = s.totalRepetitions` (from AgentState)
   - `currentRep = s.totalRepetitions - s.repetitionsRemaining` (0-based: 0 means playing first rep)
   - For silent/complete performers, set `currentRep: 0, totalReps: 0`

6. In `Ensemble.reset()`, ensure new fields reset properly (totalRepetitions resets with randomReps)
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Run existing tests if any: `npx vitest run`.
Verify FINAL_PATTERN_INDEX and BAND_WIDTH constants are completely gone from ensemble.ts (search for them).
  </verify>
  <done>
Ensemble accepts any-length Pattern[], derives finalPatternIndex and bandWidth dynamically, exposes currentRep/totalReps in performerStates. No hardcoded 52 or 3 anywhere in ensemble.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generative Pattern Factory + Score Mode Resolver</name>
  <files>src/score/generative.ts, src/score/score-modes.ts</files>
  <action>
**Create `src/score/generative.ts`:**

Implement `generateGenerativePatterns(): Pattern[]` following the CONTEXT.md character spec:

1. **Pattern count:** Random 30-80 (uniform)
2. **Progressive arc phases** based on progress (0.0-1.0):
   - `intro` (0-0.2): Shorter patterns (1-8 eighth notes), simpler intervals (steps), sparser
   - `development` (0.2-0.6): Growing length (4-16), mix of steps and leaps, increasing density
   - `climax` (0.6-0.85): Longest patterns (8-32), angular melodies, densest, widest pitch range
   - `winddown` (0.85-1.0): Shrinking length (2-8), gravitate to C, simpler intervals, sparser

3. **Pitch palette:** C major only -- MIDI notes where `midi % 12` is in `[0, 2, 4, 5, 7, 9, 11]`. Range C3-C6 (MIDI 48-84).

4. **Tonal center drift:** In development/climax phases, allow secondary centers. Implement by slightly biasing pitch selection toward G (progress 0.3-0.5) or F (progress 0.5-0.7) before returning to C bias in winddown.

5. **Note durations:** Variable within cells -- randomly select from eighth (1), quarter (2), half (4) with phase-dependent weighting. Intro/winddown favor longer durations; climax favors shorter.

6. **Rests:** Include `{midi: 0, duration: N}` notes. Probability ~20-30% per note position, higher in intro/winddown.

7. **Pulse patterns:** ~15% of patterns should be single-pitch repeated-note patterns (pick one pitch, repeat 2-6 times with varied durations).

8. **Motif bank:** Store short melodic fragments (2-4 notes) from ~30% of patterns. When generating later patterns, ~20% chance to reuse/transform a stored motif (transpose, invert, retrograde).

9. **Endgame:** Last 5 patterns: force short (2-4 notes), C-centric (bias toward C4/C5), simple steps only.

10. **Identity:** Should feel algorithmic and distinct from Riley. The wider pitch range (3 octaves vs Riley's ~2), angular leaps, and variable durations achieve this naturally.

Import `ScoreNote` and `Pattern` from `../audio/types.ts`.

**Create `src/score/score-modes.ts`:**

```typescript
import type { Pattern } from '../audio/types.ts';
import type { ScoreMode } from '../audio/types.ts';
import { PATTERNS } from './patterns.ts';
import { generateGenerativePatterns } from './generative.ts';

export function getPatternsForMode(mode: ScoreMode): Pattern[] {
  switch (mode) {
    case 'riley':
      return PATTERNS;
    case 'generative':
      return generateGenerativePatterns();
    case 'euclidean':
      // Placeholder until Plan 02 -- return Riley's patterns
      return PATTERNS;
  }
}
```

The euclidean case is a temporary placeholder that will be replaced in Plan 02.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors.
Write a quick verification script or add a temporary test: call `generateGenerativePatterns()` 3 times, verify each returns a different-length array between 30-80, all pattern IDs are sequential 1-N, all MIDI values are 0 or valid C-major notes in range 48-84, all durations are positive integers.
  </verify>
  <done>
`generateGenerativePatterns()` produces fresh, variable-length Pattern[] arrays conforming to C-major constraint with progressive arc. `getPatternsForMode('riley')` returns PATTERNS, `getPatternsForMode('generative')` returns fresh generative patterns. Euclidean placeholder returns Riley's patterns.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run` passes (existing tests still work with dynamic ensemble)
- `grep -n "FINAL_PATTERN_INDEX\|BAND_WIDTH = 3" src/score/ensemble.ts` returns nothing (constants removed)
- Generated patterns have correct structure: all MIDI notes are 0 or C-major in 48-84 range
</verification>

<success_criteria>
- Ensemble handles Pattern[] of any length without hardcoded assumptions
- PerformerState includes currentRep/totalReps fields
- Generative factory produces musically structured patterns following CONTEXT.md spec
- Score mode resolver dispatches to correct factory
- All existing functionality (Riley mode) works unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/04-composition-modes/04-01-SUMMARY.md`
</output>
